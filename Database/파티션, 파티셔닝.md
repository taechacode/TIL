# 파티션, 파티셔닝

## 파티션 개요
- `파티셔닝(Partitioning)`은 테이블 또는 인덱스 데이터를 파티션 단위로 나누어 저장하는 것을 말한다.
- 테이블을 파티셔닝하면 파티션 키에 따라 물리적으로는 별도의 세그먼트에 데이터를 저장하며, 인덱스도 마찬가지다.
- 파티션이 필요한 이유를 관리적 측면과 성능적 측면으로 나누어 볼 수 있다.
  - 관리적 측면 : 파티션 단위 백업, 추가, 삭제, 변경
  - 성능적 측면 : 파티션 단위 조회 및 DML 수행, 경합 및 부하 분산

<br/>

- 파티셔닝은 우선 관리 측면에서 많은 이점이 있다.
- 보관주기가 지난 데이터를 별도 장치에 백업하고 지우는 일은 데이터베이스 관리자들의 일상적인 작업이다. 만약 파티션 없이 대용량 테이블에 이런 작업을 수행하려면 시간도 오래 걸리고 비효율적이다.
- 대용량 테이블에 인덱스를 새로 생성하거나 재생성할 때도 파티션 기능을 이용하면 효과적이다.

<br/>

- 파티셔닝은 성능 측면에서의 효용성도 매우 좋다.
- 데이터를 빠르게 검색할 목적으로 데이터베이스마다 다양한 저장구조와 검색 기법들이 개발되고 있지만, 인덱스를 이용하는 방법과 테이블 전체를 스캔하는 두 가지 방법에서 크게 벗어나지는 못하고 있다.
- 인덱스를 이용한 랜덤 액세스 방식은 일정량을 넘는 순간 Full Table Scan보다 오히려 성능이 떨어진다. 그렇다고 초대용량 테이블을 Full Scan하는 것은 매우 비효율적이다.
- 이런 경우 테이블을 파티션 단위로 나누어 관리하면, Full Table Scan이라 하더라도 일부 세그먼트만 읽고 작업을 마칠 수 있다.

<br/>

- 테이블이나 인덱스를 파티셔닝하면 DBMS는 내부에 2개 이상(생성 초기에 하나일 수는 있으나 계속 하나를 유지한다면 파티셔닝은 불필요)의 저장영역을 생성하고, 그것들이 논리적으로 하나의 오브젝트임을 `메타정보`로 관리한다.
- `파티션되지 않은 일반 테이블`일 때는 테이블과 저장영역(Oracle의 세그먼트)이 `1:1 관계`지만 `파티션 테이블`일 때는 `1:M 관계`다. 인덱스를 파티셔닝할 때도 마찬가지다.

<br/>

## 파티션 분할 기준

### 가. Range 파티셔닝
- 파티션 키 값의 범위(Range)로 분할
- 파티셔닝의 가장 일반적인 형태이며, 주로 날짜 칼럼을 기준으로 함(예, 판매 데이터를 월별로 분할)

### 나. Hash 파티셔닝
- 파티션 키 값에 해시 함수를 적용하고, 거기서 반환된 값으로 파티션 매핑
- 데이터가 모든 파티션에 고르게 분산되도록 DBMS가 관리 -> 각 로우의 저장 위치 예측 불가
- 파티션 키의 데이터 분포가 고른 칼럼이어야 효과적
  - 예) 고객번호, 주문일련번호 등
- 병렬처리 시 성능효과 극대화
- DML 경합 분산에 효과적
  - `경합(Race Condition)` : 공유 자원에 대해 여러 프로세스가 동시에 접근을 시도할 때, 타이밍이나 순서 등이 결과값에 영향을 줄 수 있는 상태. 공유 자원에 여러 프로세스가 동시에 접근할 때 **자료의 일관성을 해치는 결과**가 나타날 수 있다.

### 다. List 파티셔닝
- 불연속적인 값의 목록을 각 파티션에 지정
- 순서와 상관없이, 사용자가 미리 정한 기준에 따라 데이터를 분할 저장
  - 예) 판매 데이터를 지역별로 분할

### 라. Composite 파티셔닝
- Range나 List 파티션 내에 또 다른 서브 파티션(Range, Hash, List) 구성
  - 예) Range + List 또는 List + Hash 등
- Range나 List 파티션이 갖는 이점 + 각 서브 파티션 구성의 이점

![Oracle버전별파티션지원유형](https://github.com/taechacode/TIL/assets/63395751/2cb6bf22-2b8b-41a3-98ba-7edd10f7e9e2)

<br/>

## 파티셔닝 종류

### 1. 수평 파티셔닝 (Horizontal Partitioning)

![수평파티셔닝](https://github.com/taechacode/TIL/assets/63395751/79eea541-6c74-4108-81cb-700261584a4c)

- 수평 파티셔닝은 하나의 테이블에 각 행을 다른 테이블에 분산시키는 것이다.
- 위 그림과 같이 5개의 행이 있는 테이블을 각각 3개, 2개의 행을 가진 테이블로 쪼갤 수 있다.

#### 예시
- 고객의 데이터베이스를 CustomerId를 샤드키로 사용하여 샤딩하기로 하자.
  - 0 ~ 10000번 고객의 정보는 하나의 샤드에 저장하고 10001 ~ 20000번 고객의 정보는 다른 샤드에 저장한다.
  - DBA는 데이터 액세스 패턴과 저장 공간 이슈(로드의 적절한 분산, 데이터의 균등한 저장)를 고려하여 적절한 샤드키를 결정한다.
- 같은 주민 데이터를 처리하기 위해 스키마가 같은 '서현동 주민 테이블'과 '정자동 주민 테이블'을 사용하는 것을 말한다.
  - 인덱스의 크기를 줄이고, 작업 동시성을 늘리기 위한 것이다.

#### 장점
- 데이터의 개수를 기준으로 나누어 파티셔닝한다.
- 데이터의 개수와 인덱스의 개수가 줄어들어 성능이 향상된다.

#### 단점
- 데이터를 찾는 과정이 기존보다 복잡하므로 Latency가 증가한다.

### 참고 : 샤딩(Sharding)이란?
- 샤딩은 같은 테이블 스키마를 가진 데이터를 다수의 데이터베이스에 분산하여 저장하는 기법을 뜻한다.
- 종종 샤딩과 수평 파티셔닝이 같은 의미로 사용되지만 사실 둘은 조금 다른 측면이 있다.

![수평파티셔닝샤딩](https://github.com/taechacode/TIL/assets/63395751/196e1686-bc1e-4e85-845f-4ed3b1cc7c4e)

- 수평 파티셔닝은 **같은 데이터베이스 내에서** 하나의 큰 테이블을 쪼개 분산 저장하는 기법이다.
- 반면, 샤딩은 하나의 큰 테이블을 쪼개 **각각 다른 데이터베이스에** 분산 저장하는 기법이다.
- 이러한 샤딩은 수평 파티셔닝의 장점을 모두 갖는다.
- 샤딩은 데이터베이스 서버 간의 연결 과정이 많아져 비용(cost)이 증가할 수 있다. 또한 하나의 서버가 고장나면 데이터의 무결성이 깨질 수 있다는 단점도 있다.

<br/>

### 2. 수직 파티셔닝 (Vertical Partitioning)

![수직파티셔닝](https://github.com/taechacode/TIL/assets/63395751/d6fa3871-a0e4-47a9-bc48-e251cf1320da)

- 모든 칼럼들 중 특정 칼럼들을 쪼개서 따로 저장하는 형태를 의미한다. 스키마(schema)를 나누고 데이터가 따라 옮겨가는 것을 말한다.
- 하나의 엔티티를 2개 이상으로 분리하는 작업이다.
- 수직 파티셔닝은 테이블의 일부 열을 빼내는 형태로 분할한다. 즉, 테이블의 칼럼을 기준으로 나누어 파티셔닝한다.
- 정규화도 수직 파티셔닝과 관련된 과정이라고 할 수 있다. 하지만 수직 파티셔닝은 이미 정규화된 데이터를 분리하는 과정이라고 생각해야 한다.

#### 예시
- 하나의 고객은 하나의 청구 주소를 가지고 있을 수 있다.
- 그러나 데이터 유연성을 위해 다른 데이터베이스로 정보를 이동하거나 보안 이슈를 이유로 CustomerId를 참조하도록 하고 청구 주소 정보를 다른 테이블로 분리할 수 있다.

#### 장점
- 자주 사용하는 칼럼을 분리하여 성능을 향상할 수 있다.
- 같은 타입의 데이터가 저장되어 데이터 압축률을 높일 수 있다.
- 조회 시 필요 없는 칼럼을 조회하지 않아도 되므로 성능상의 이점이 있다.
- 한 테이블을 SELECT하면 결국 모든 칼럼을 메모리에 올리게 되므로 필요없는 칼럼까지 올라가서 한 번에 읽을 수 있는 ROW가 줄어든다. 수직 파티셔닝을 통해 I/O 측면에서 필요한 칼럼만 올리면 훨씬 많은 수의 ROW를 메모리에 올릴 수 있으니 성능상의 이점이 있다.

#### 단점
- 데이터를 찾는 과정이 기존보다 복잡하므로 Latency가 증가한다.

<br/>

## 파티션 테이블 만들기 예시

```
SQL> create table partition_table
  2  partition by range(deptno) (
  3    partition p1 values less than(20)
  4  , partition p2 values less than(30)
  5  , partition p3 values less than(40)
  6  )
  7  as
  8  select * from emp ;
테이블이 생성되었습니다.

SQL> create index ptable_empno_idx on partition_table(empno) LOCAL;
인덱스가 생성되었습니다.
```

- 위의 파티션 테이블을 정의하면 3개의 세그먼트가 생성된다.
- 인덱스 생성시도 LOCAL 옵션을 지정했으므로 각 파티션별로 개별적인 인덱스가 생성된다.
- 내부에 몇 개의 세그먼트를 생성하고 그것들이 논리적으로 하나의 오브젝트임을 메타정보로 딕셔너리에 저장해두는 것에 지나지 않는다.

### Range 파티셔닝 예시
```
-- Range 파티셔닝
create table 주문( 주문번호 number, 주문일자 varchar2(8), 고객id varchar2(5) )
partition by range(주문일자) (
  partition p2009_q1 values less than('20090401')
, partition p2009_q2 values less than('20090701')
, partition p2009_q3 values less than('20091001')
, partition p2009_q4 values less than('20100101')
, partition p2010_q1 values less than('20100401')
, partition p9999_mx values less than( MAXVALUE )
);
```

<br/>

![Range파티셔닝참고사진](https://github.com/taechacode/TIL/assets/63395751/afd801e6-cac1-4292-bc2c-b5f1b7179284)

<br/>

- 위와 같이 파티셔닝 테이블에 값을 입력하면 각 레코드를 파티션 키 칼럼 값에 따라 분할 저장하고, 읽을 때도 검색 조건을 만족하는 파티션만 읽을 수 있어 이력성 데이터 조회 시 성능을 크게 향상시켜 준다.
- 파티션 키로는 하나 이상의 칼럼을 지정할 수 있고, 최대 16개까지 허용된다.
- 보관 주기 정책에 따라 과거 데이터가 저장된 파티션만 백업하고 삭제하는 등 데이터관리 작업을 효율적이고 빠르게 수행할 수 있는 것도 큰 장점이다.
- DBA의 실수로 신규 파티션 생성을 빠뜨리면 월초 또는 연초에 데이터가 입력되지 않는 에러가 발생하므로, maxvalue 파티션을 반드시 생성해두는 것이 좋다.

<br/>

```
create table 주문일자 (주문번호 number, 주문일시 date, ... )
partition by range(주문일시) INTERVAL(NUMTOYMINTERVAL(1, 'MONTH'))  
(
, partition p200907 values less than(to_date('2009/08/01', 'yyyy/mm/dd'))
, partition p200908 values less than(to_date('2009/09/01', 'yyyy/mm/dd'))
, partition p200909 values less than(to_date('2009/10/01', 'yyyy/mm/dd'))
, partition p200910 values less than(to_date('2009/11/01', 'yyyy/mm/dd'))
);



create table 고객 (고객번호 number, 고객명 varchar2(20), ... )
partition by range(고객번호) INTERVAL (100000)
( partition p_cust1 values less than ( 100001 )
, partition p_cust2 values less than ( 200001 ) 
, partition p_cust3 values less than ( 300001 ) 
) ;
```

- Oracle 11g부터는 Range 파티션을 생성할 때 `Interval 기준`을 정의함으로써 정해진 간격으로 파티션이 자동추가 되도록 할 수 있다.

<br/>

***출처***<br/>
***https://nesoy.github.io/articles/2018-02/Database-Partitioning***<br/>
***http://theeye.pe.kr/archives/1917***<br/>
***http://www.gurubee.net/lecture/1906***<br/>
***http://wiki.gurubee.net/pages/viewpage.action?pageId=3899999***<br/>
***http://wiki.gurubee.net/pages/viewpage.action?pageId=26742648***<br/>
***https://gmlwjd9405.github.io/2018/09/24/db-partitioning.html***
