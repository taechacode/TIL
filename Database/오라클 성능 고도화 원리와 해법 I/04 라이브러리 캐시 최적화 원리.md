# 04. 커서 공유

## (1) 커서란?

## (2) 커서 공유
- **"커서를 공유한다"** 는 표현에서 커서는 라이브러리 캐시의 공유 커서를 일컫는다. (세션 커서 x, 애플리케이션 커서 x)
- 라이브러리 캐시에 공유돼 있는 커서의 수행 통계는 v$sql을 통해서 확인 가능.
    - parse_calls : 라이브러리 캐시에서 SQL 커서를 찾으려는 요청 횟수
    - loads : 하드파싱을 거친 SQL 실행계획을 라이브러리 캐시에 적재한 횟수
    - executions : SQL을 실행한 횟수
    - invalidations : 커서가 무효화된 횟수. 커서가 참조하고 있는 오브젝트에 중요한 변화가 일어났음을 의미함.
- parse_calls 3, loads 1이면 라이브러리 캐시에서 SQL을 3번 찾았고, 하드파싱은 1번 일어난 것을 의미한다.
- 다른 세션에서 같은 SQL을 수행할 때도 이전 세션에서 적재한 커서를 재사용한다.
- 공유된 커서를 사용할 때는 최적화 및 Row-Source Generation 단계를 생략하고 곧바로 실행 단계로 넘어가므로 보다 효율적이고 빠르게 SQL 수행할 수 있다.
- 라이브러리 캐시에서 커서를 식별하기 위해 사용되는 키 값은 `SQL 문장 그 자체`이다.

## (3) Child 커서를 공유하지 못하는 경우
- SQL 문장이 100% 동일해도 SQL 커서를 공유하지 못하고 별도의 SQL 커서를 생성해야 할 때도 있다. (동일한 테이블이 각기 다른 스키마에 생성되어있을 경우)
- SQL마다 하나의 Parent 커서를 가지며, Child 커서를 여러 개일 수 있다. 실제 수행에 필요한 정보는 Child 커서에 담기므로 적어도 1개의 Child 커서를 갖는다.
- Version Count 수치(Child 커서 개수)가 높은 SQL 일수록 커서를 탐색하는데 더 많은 시간을 소비하므로 library cache 래치에 대한 경합 발생 가능성을 증가시킨다.
- 하나의 SQL 문장이 여러 개 Child 커서를 갖게 되는 이유
    - SQL에서 참조하는 오브젝트명이 같지만 SQL을 실행한 사용자에 따라 다른 오브젝트를 가리킬 때
    - 참조오브젝트가 변경돼 커서가 무효화되면 이후 그 커서를 처음 사용하려는 세션에 의해 다시 하드파싱돼야 하는데, 특정 세션이 아직 기존 커서를 사용 중(Pin)일 때
    - 옵티마이저 모드를 비롯해 옵티마이저 관련 파라미터가 다를 때
    - 입력된 바인드 값의 길이가 크게 다를 때
    - NLS 파라미터를 다르게 설정했을 때
    - SQL 트레이스를 활성화했을 때