# 4장 조인 튜닝


## 4.1 NL 조인


### 4.1.1 기본 메커니즘
- NL 조인은 중첩 루프문과 같은 수행 구조를 사용한다.
- 일반적으로 NL 조인은 Outer와 Inner 양쪽 테이블 모두 인덱스를 이용한다.
- Outer 쪽 테이블은 사이즈가 크지 않으면 인덱스를 이용하지 않을 수 있다. Table Full Scan 하더라도 그것은 한 번에 그치기 때문이다.
- 반면, Inner 쪽 테이블은 인덱스를 사용해야한다. Inner 루프에서 데이터를 검색할 때 인덱스를 이용하지 않으면, Outer 루프에서 읽은 건수만큼 Table Full Scan을 반복하기 때문이다.


### 4.1.2 NL 조인 실행계획 제어
- `ordered` 힌트는 FROM 절에 기술한 순서대로 조인하라고 옵티마이저에 지시할 때 사용한다. `ordered` 대신 `leading` 힌트를 사용할 수도 있다. 이 힌트를 사용하면 FROM 절을 바꾸지 않고 순서를 제어할 수 있어 편리하다.
- `use_nl` 힌트는 NL 방식으로 조인하라고 지시할 때 사용한다.
- `index` 힌트는 인덱스를 이용해서 액세스하라고 지시할 때 사용한다. 인덱스명을 명시하지 않으면 어떤 인덱스를 사용할지는 옵티마이저가 결정한다.


### 4.1.3 NL 조인 수행 과정 분석
```
SELECT /*+ ordered use_nl(C) index(E) index(C) */
FROM 사원 E, 고객 C
WHERE C.관리사원번호 = E.사원번호
AND   E.입사일자 >= '19960101'
AND   E.부서코드 = 'Z123'
AND   C.최종주문금액 >= 20000
```
```
* 사원_PK : 사원번호
* 사원_X1 : 입사일자
* 고객_PK : 고객번호
* 고객_X1 : 관리사원번호
* 고객_X2 : 최종주문금액
```

### 4.1.4 NL 조인 튜닝 포인트
- 첫 번째 튜닝 포인트는 사원_X1 인덱스를 읽고 나서 사원 테이블을 액세스하는 부분이다. 여기서는 단일 컬럼 액세스를 `>=` 조건으로 스캔했으므로 비효율 없이 6(=5+1)건을 읽었고, 그만큼 테이블 랜덤 액세스가 발생했다.
- 만약 사원 테이블로 아주 많은 양의 랜덤 액세스가 발생했고, 테이블에서 부서코드 = 'Z123' 조건에 의해 필터링되는 비율이 높다면 어떻게 해야 할까? 사원_X1 인덱스에 부서코드 컬럼을 추가하는 방안을 고려해야 한다.
- 두 번째 튜닝 포인트는 고객_X1 인덱스를 탐색하는 부분이다. 고객_X1 인덱스를 탐색하는 횟수, 즉 조인 액세스 횟수가 많을수록 성능이 느려진다. 조인 액세스 횟수는 Outer 테이블인 사원을 읽고 필터링한 결과 건수에 의해 결정된다.
- 만약 부서코드 조건을 만족하는 레코드가 10만 건이고 고객_X1 인덱스 Depth가 3이라면 인덱스 수직적 탐색 과정에서만 30만(=10만x3)개 블록을 읽어야 하고, 리프 블록을 수평적으로 스캔하는 과정에서 추가적인 블록I/O가 더해진다.
- 세 번째 튜닝 포인트는 고객_X1 인덱스를 읽고 나서 고객 테이블을 액세스하는 부분이다. 여기서도 최종주문금액 >= 20000 조건에 의해 필터링되는 비율이 높다면 고객_X1 인덱스에 최종주문금액 컬럼을 추가하는 방안을 고려해야 한다.
- 마지막으로, 맨 처음 액세스하는 사원_X1 인덱스에서 얻은 결과 건수에 의해 전체 일량이 좌우된다. 사원_X1 인덱스를 스캔하면서 추출한 레코드가 많으면, 사원 테이블로 랜덤 액세스하는 횟수, 고객_X1 인덱스를 탐색하는 횟수, 고객 테이블로 랜덤 액세스하는 횟수가 전반적으로 많아진다.

#### 올바른 조인 메소드 선택
- 온라인 트랜잭션 처리(OLTP) 시스템에서 튜닝할 때는 일차적으로 NL 조인부터 고려하는 것이 올바른 순서다.
- 성능이 느리다면, NL 조인 튜닝 포인트에 따라 각 단계의 수행 일량을 분석해서 과도한 랜덤 액세스가 발생하는 지점을 우선 파악한다. 조인 순서를 변경해서 랜덤 액세스 발생량을 줄일 수 있는지, 더 효과적인 다른 인덱스가 있는지 등을 검토한다. 필요하다면, 인덱스 추가 또는 구성 변경도 고려해 본다.
- 여러 방안을 검토한 결과 NL 조인으로 결코 좋은 성능을 내기 어렵다고 판단될 때, 소트 머지 조인이나 해시 조인을 검토한다.


### 4.1.5 NL 조인 특징 요약
- NL 조인의 첫 번째 특징은 `랜덤 액세스 위주`의 조인 방식이라는 점이다. 레코드 하나를 읽으려고 블록을 통째로 읽는 랜덤 액세스 방식은 설령 메모리 버퍼에서 빠르게 읽더라도 비효율이 존재한다.
- 두 번째 특징은 조인을 `한 레코드씩 순차적으로 진행`한다는 점이다. 첫 번째 특징 때문에 대량 데이터 처리 시 매우 치명적인 한계를 드러내지만, 반대로 부분범위 처리가 가능한 상황에서 이 두 번째 특징 때문에 아무리 큰 테이블을 조인하더라도 매우 빠른 응답 속도를 낼 수 있다.
- 순차적으로 진행하므로 먼저 액세스되는 테이블 처리 범위에 의해 전체 일량이 결정되는 특징도 나타난다.
- 마지막으로, 다른 조인 방식과 비교할 때 `인덱스 구성 전략이 특히 중요`하다는 것도 NL조인의 중요한 특징이다. 조인 컬럼에 대한 인덱스가 있느냐 없느냐, 있다면 컬럼이 어떻게 구성 됐느냐에 따라 조인 효율이 크게 달라진다.
- 위의 여러 가지 특징들을 종합할 때, NL 조인은 소량 데이터를 주로 처리하거나 부분범위 처리가 가능한 `온라인 트랜잭션 처리(OLTP) 시스템에 적합`한 조인 방식이라고 할 수 있다.


### 4.1.6 NL 조인 튜닝 실습


### 4.1.7 NL 조인 확장 메커니즘


## 4.2 소트 머지 조인
- 조인 컬럼에 인덱스가 없을 때, 대량 데이터 조인이어서 인덱스가 효과적이지 않을 때, 옵티마이저는 NL 조인 대신 소트 머지 조인이나 해시 조인을 선택한다.

### 4.2.1 SGA vs PGA
- 공유 메모리 영역인 SGA에 캐시된 데이터는 여러 프로세스가 공유할 수 있다. 여러 프로세스가 공유할 수 있지만, 동시에 액세스할 수는 없다. 동시에 액세스하려는 프로세스 간 액세스를 직렬화하기 위한 Lock 메커니즘으로서 `래치(Latch)`가 존재한다. 데이터 블록과 인덱스 블록을 캐싱하는 DB 버퍼캐시는 SGA의 가장 핵심적인 구성요소이며, 여기서 블록을 읽으려면 버퍼 Lock도 얻어야 한다.
- 오라클 서버 프로세스는 SGA에 공유된 데이터를 읽고 쓰면서, 동시에 자신만의 고유 메모리 영역을 갖는다. 각 오라클 서버 프로세스에 할당된 메모리 영역을 `PGA(Process/Program/Private Global Area)`라고 부르며, 프로세스 종속적인 고유 데이터를 저장하는 용도로 사용한다. 할당받은 PGA 공간이 작아 데이터를 모두 저장할 수 없을 때는 Temp 테이블 스페이스를 사용한다.
- PGA는 다른 프로세스와 공유하지 않는 독립적인 메모리 공간이므로 `래치 메커니즘이 불필요`하다. 따라서 `같은 양의 데이터를 읽더라도 SGA 버퍼캐시에서 읽을 때보다 훨씬 빠르다.`


### 4.2.2 기본 메커니즘
- 소트 머지 조인(Sort Merge Join)은 아래 두 단계로 진행한다.
    - 1. 소트 단계 : 양쪽 집합을 조인 컬럼 기준으로 정렬한다.
    - 2. 머지 단계 : 정렬한 양쪽 집합을 서로 머지(Merge)한다.
- 소트 머지 조인 방식을 유도하는 힌트는 `use_merge`이다.
- 소트 단계에서 정렬한 결과집합은 PGA 영역에 할당된 Sort Area에 저장한다. 정렬된 결과집합이 PGA에 담을 수 없을 정도로 크면, Temp 테이블스페이스에 저장한다.
- Sort Area에 저장한 데이터 자체가 인덱스 역할을 하므로 소트 머지 조인은 조인 컬럼에 인덱스가 없어도 사용할 수 있는 조인 방식이다. 조인 컬럼에 인덱스가 있어도 NL 조인은 대량 데이터 조인할 때 불리하므로 소트 머지 조인을 사용할 수 있다.


### 4.2.3 소트 머지 조인이 빠른 이유
- NL 조인은 `인덱스를 이용한 조인 방식`이다. 
    - 조인 과정에서 액세스하는 모든 블록을 랜덤 액세스 방식으로 건건이 DB 버퍼캐시를 경유해서 읽는다.
    - 즉, 인덱스든 테이블이든, 읽는 모든 블록에 래치 획득 및 캐시버퍼 체인 스캔 과정을 거친다.
    - 버퍼캐시에서 찾지 못한 블록은 건건이 디스크에서 읽어 들인다.
    - 인덱스를 이용하기 때문에 인덱스 손익분기점 한계를 그대로 드러낸다.
- 소트 머지 조인은 양쪽 테이블로부터 조인 대상 집합(조인 조건 이외 필터 조건을 만족하는 집합)을 `일괄적으로` 읽어 PGA(또는 Temp 테이블스페이스)에 저장한 후 조인한다.
    - PGA는 프로세스만을 독립적인 메모리 공간이므로 데이터를 읽을 때 래치 획득 과정이 없다. 소트 머지 조인이 대량 데이터 조인에 유리한 이유다.
    - 소트 머지 조인도 양쪽 테이블로부터 조인 대상 집합을 읽을 때는 DB 버퍼캐시를 경유한다. 이때 인덱스를 이용하기도 한다. 이 과정에서 생기는 버퍼캐시 탐색 비용과 랜덤 액세스 부하는 소트 머지 조인도 피할 수 없다.


### 4.2.4 소트 머지 조인의 주용도
- 조인 조건식이 등치(=) 조건이 아닌 대량 데이터 조인
- 조인 조건식이 아예 없는 조인(Cross Join, 카테시안 곱)


### 4.2.5 소트 머지 조인 제어하기


### 4.2.6 소트 머지 조인 특징 요약
- 소트 머지 조인은 조인을 위해 실시간으로 인덱스를 생성하는 것과 다름없다. 
- 양쪽 집합을 정렬한 다음에는 NL 조인과 같은 방식으로 진행하지만, PGA 영역에 저장한 데이터를 이용하기 때문에 빠르다. 따라서 소트 부하만 감수한다면, 건건이 버퍼캐시를 경유하는 NL 조인보다 빠르다.
- NL 조인은 조인 컬럼에 대한 인덱스 유무에 크게 영향을 받지만, 소트 머지 조인은 영향을 받지 않는다. 따라서 조인 컬럼에 인덱스가 없는 상황에서 두 테이블을 각각 읽어 조인 대상 집합을 줄일 수 있을 때 아주 유리하다.
- 스캔 위주의 액세스 방식을 사용하지만 모든 처리가 스캔 방식으로 이루어지진 않는다. 양쪽 소스 집합으로부터 조인 대상 레코드를 찾는 데 인덱스를 이용할 수 있고, 그때는 랜덤 액세스가 일어난다.