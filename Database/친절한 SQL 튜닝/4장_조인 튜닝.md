# 4장 조인 튜닝


## 4.1 NL 조인


### 4.1.1 기본 메커니즘
- NL 조인은 중첩 루프문과 같은 수행 구조를 사용한다.
- 일반적으로 NL 조인은 Outer와 Inner 양쪽 테이블 모두 인덱스를 이용한다.
- Outer 쪽 테이블은 사이즈가 크지 않으면 인덱스를 이용하지 않을 수 있다. Table Full Scan 하더라도 그것은 한 번에 그치기 때문이다.
- 반면, Inner 쪽 테이블은 인덱스를 사용해야한다. Inner 루프에서 데이터를 검색할 때 인덱스를 이용하지 않으면, Outer 루프에서 읽은 건수만큼 Table Full Scan을 반복하기 때문이다.


### 4.1.2 NL 조인 실행계획 제어
- `ordered` 힌트는 FROM 절에 기술한 순서대로 조인하라고 옵티마이저에 지시할 때 사용한다. `ordered` 대신 `leading` 힌트를 사용할 수도 있다. 이 힌트를 사용하면 FROM 절을 바꾸지 않고 순서를 제어할 수 있어 편리하다.
- `use_nl` 힌트는 NL 방식으로 조인하라고 지시할 때 사용한다.
- `index` 힌트는 인덱스를 이용해서 액세스하라고 지시할 때 사용한다. 인덱스명을 명시하지 않으면 어떤 인덱스를 사용할지는 옵티마이저가 결정한다.


### 4.1.3 NL 조인 수행 과정 분석
```
SELECT /*+ ordered use_nl(C) index(E) index(C) */
FROM 사원 E, 고객 C
WHERE C.관리사원번호 = E.사원번호
AND   E.입사일자 >= '19960101'
AND   E.부서코드 = 'Z123'
AND   C.최종주문금액 >= 20000
```
```
* 사원_PK : 사원번호
* 사원_X1 : 입사일자
* 고객_PK : 고객번호
* 고객_X1 : 관리사원번호
* 고객_X2 : 최종주문금액
```

### 4.1.4 NL 조인 튜닝 포인트
- 첫 번째 튜닝 포인트는 사원_X1 인덱스를 읽고 나서 사원 테이블을 액세스하는 부분이다. 여기서는 단일 컬럼 액세스를 `>=` 조건으로 스캔했으므로 비효율 없이 6(=5+1)건을 읽었고, 그만큼 테이블 랜덤 액세스가 발생했다.
- 만약 사원 테이블로 아주 많은 양의 랜덤 액세스가 발생했고, 테이블에서 부서코드 = 'Z123' 조건에 의해 필터링되는 비율이 높다면 어떻게 해야 할까? 사원_X1 인덱스에 부서코드 컬럼을 추가하는 방안을 고려해야 한다.
- 두 번째 튜닝 포인트는 고객_X1 인덱스를 탐색하는 부분이다. 고객_X1 인덱스를 탐색하는 횟수, 즉 조인 액세스 횟수가 많을수록 성능이 느려진다. 조인 액세스 횟수는 Outer 테이블인 사원을 읽고 필터링한 결과 건수에 의해 결정된다.
- 만약 부서코드 조건을 만족하는 레코드가 10만 건이고 고객_X1 인덱스 Depth가 3이라면 인덱스 수직적 탐색 과정에서만 30만(=10만x3)개 블록을 읽어야 하고, 리프 블록을 수평적으로 스캔하는 과정에서 추가적인 블록I/O가 더해진다.
- 세 번째 튜닝 포인트는 고객_X1 인덱스를 읽고 나서 고객 테이블을 액세스하는 부분이다. 여기서도 최종주문금액 >= 20000 조건에 의해 필터링되는 비율이 높다면 고객_X1 인덱스에 최종주문금액 컬럼을 추가하는 방안을 고려해야 한다.
- 마지막으로, 맨 처음 액세스하는 사원_X1 인덱스에서 얻은 결과 건수에 의해 전체 일량이 좌우된다. 사원_X1 인덱스를 스캔하면서 추출한 레코드가 많으면, 사원 테이블로 랜덤 액세스하는 횟수, 고객_X1 인덱스를 탐색하는 횟수, 고객 테이블로 랜덤 액세스하는 횟수가 전반적으로 많아진다.

#### 올바른 조인 메소드 선택
- 온라인 트랜잭션 처리(OLTP) 시스템에서 튜닝할 때는 일차적으로 NL 조인부터 고려하는 것이 올바른 순서다.
- 성능이 느리다면, NL 조인 튜닝 포인트에 따라 각 단계의 수행 일량을 분석해서 과도한 랜덤 액세스가 발생하는 지점을 우선 파악한다. 조인 순서를 변경해서 랜덤 액세스 발생량을 줄일 수 있는지, 더 효과적인 다른 인덱스가 있는지 등을 검토한다. 필요하다면, 인덱스 추가 또는 구성 변경도 고려해 본다.
- 여러 방안을 검토한 결과 NL 조인으로 결코 좋은 성능을 내기 어렵다고 판단될 때, 소트 머지 조인이나 해시 조인을 검토한다.


### 4.1.5 NL 조인 특징 요약
- NL 조인의 첫 번째 특징은 `랜덤 액세스 위주`의 조인 방식이라는 점이다. 레코드 하나를 읽으려고 블록을 통째로 읽는 랜덤 액세스 방식은 설령 메모리 버퍼에서 빠르게 읽더라도 비효율이 존재한다.
- 두 번째 특징은 조인을 `한 레코드씩 순차적으로 진행`한다는 점이다. 첫 번째 특징 때문에 대량 데이터 처리 시 매우 치명적인 한계를 드러내지만, 반대로 부분범위 처리가 가능한 상황에서 이 두 번째 특징 때문에 아무리 큰 테이블을 조인하더라도 매우 빠른 응답 속도를 낼 수 있다.
- 순차적으로 진행하므로 먼저 액세스되는 테이블 처리 범위에 의해 전체 일량이 결정되는 특징도 나타난다.
- 마지막으로, 다른 조인 방식과 비교할 때 `인덱스 구성 전략이 특히 중요`하다는 것도 NL조인의 중요한 특징이다. 조인 컬럼에 대한 인덱스가 있느냐 없느냐, 있다면 컬럼이 어떻게 구성 됐느냐에 따라 조인 효율이 크게 달라진다.
- 위의 여러 가지 특징들을 종합할 때, NL 조인은 소량 데이터를 주로 처리하거나 부분범위 처리가 가능한 `온라인 트랜잭션 처리(OLTP) 시스템에 적합`한 조인 방식이라고 할 수 있다.


### 4.1.6 NL 조인 튜닝 실습


### 4.1.7 NL 조인 확장 메커니즘


## 4.2 소트 머지 조인
- 조인 컬럼에 인덱스가 없을 때, 대량 데이터 조인이어서 인덱스가 효과적이지 않을 때, 옵티마이저는 NL 조인 대신 소트 머지 조인이나 해시 조인을 선택한다.

### 4.2.1 SGA vs PGA
- 공유 메모리 영역인 SGA에 캐시된 데이터는 여러 프로세스가 공유할 수 있다. 여러 프로세스가 공유할 수 있지만, 동시에 액세스할 수는 없다. 동시에 액세스하려는 프로세스 간 액세스를 직렬화하기 위한 Lock 메커니즘으로서 `래치(Latch)`가 존재한다. 데이터 블록과 인덱스 블록을 캐싱하는 DB 버퍼캐시는 SGA의 가장 핵심적인 구성요소이며, 여기서 블록을 읽으려면 버퍼 Lock도 얻어야 한다.
- 오라클 서버 프로세스는 SGA에 공유된 데이터를 읽고 쓰면서, 동시에 자신만의 고유 메모리 영역을 갖는다. 각 오라클 서버 프로세스에 할당된 메모리 영역을 `PGA(Process/Program/Private Global Area)`라고 부르며, 프로세스 종속적인 고유 데이터를 저장하는 용도로 사용한다. 할당받은 PGA 공간이 작아 데이터를 모두 저장할 수 없을 때는 Temp 테이블 스페이스를 사용한다.
- PGA는 다른 프로세스와 공유하지 않는 독립적인 메모리 공간이므로 `래치 메커니즘이 불필요`하다. 따라서 `같은 양의 데이터를 읽더라도 SGA 버퍼캐시에서 읽을 때보다 훨씬 빠르다.`


### 4.2.2 기본 메커니즘
- 소트 머지 조인(Sort Merge Join)은 아래 두 단계로 진행한다.
    - 1. 소트 단계 : 양쪽 집합을 조인 컬럼 기준으로 정렬한다.
    - 2. 머지 단계 : 정렬한 양쪽 집합을 서로 머지(Merge)한다.
- 소트 머지 조인 방식을 유도하는 힌트는 `use_merge`이다.
- 소트 단계에서 정렬한 결과집합은 PGA 영역에 할당된 Sort Area에 저장한다. 정렬된 결과집합이 PGA에 담을 수 없을 정도로 크면, Temp 테이블스페이스에 저장한다.
- Sort Area에 저장한 데이터 자체가 인덱스 역할을 하므로 소트 머지 조인은 조인 컬럼에 인덱스가 없어도 사용할 수 있는 조인 방식이다. 조인 컬럼에 인덱스가 있어도 NL 조인은 대량 데이터 조인할 때 불리하므로 소트 머지 조인을 사용할 수 있다.


### 4.2.3 소트 머지 조인이 빠른 이유
- NL 조인은 `인덱스를 이용한 조인 방식`이다. 
    - 조인 과정에서 액세스하는 모든 블록을 랜덤 액세스 방식으로 건건이 DB 버퍼캐시를 경유해서 읽는다.
    - 즉, 인덱스든 테이블이든, 읽는 모든 블록에 래치 획득 및 캐시버퍼 체인 스캔 과정을 거친다.
    - 버퍼캐시에서 찾지 못한 블록은 건건이 디스크에서 읽어 들인다.
    - 인덱스를 이용하기 때문에 인덱스 손익분기점 한계를 그대로 드러낸다.
- 소트 머지 조인은 양쪽 테이블로부터 조인 대상 집합(조인 조건 이외 필터 조건을 만족하는 집합)을 `일괄적으로` 읽어 PGA(또는 Temp 테이블스페이스)에 저장한 후 조인한다.
    - PGA는 프로세스만을 독립적인 메모리 공간이므로 데이터를 읽을 때 래치 획득 과정이 없다. 소트 머지 조인이 대량 데이터 조인에 유리한 이유다.
    - 소트 머지 조인도 양쪽 테이블로부터 조인 대상 집합을 읽을 때는 DB 버퍼캐시를 경유한다. 이때 인덱스를 이용하기도 한다. 이 과정에서 생기는 버퍼캐시 탐색 비용과 랜덤 액세스 부하는 소트 머지 조인도 피할 수 없다.


### 4.2.4 소트 머지 조인의 주용도
- 조인 조건식이 등치(=) 조건이 아닌 대량 데이터 조인
- 조인 조건식이 아예 없는 조인(Cross Join, 카테시안 곱)


### 4.2.5 소트 머지 조인 제어하기


### 4.2.6 소트 머지 조인 특징 요약
- 소트 머지 조인은 조인을 위해 실시간으로 인덱스를 생성하는 것과 다름없다. 
- 양쪽 집합을 정렬한 다음에는 NL 조인과 같은 방식으로 진행하지만, PGA 영역에 저장한 데이터를 이용하기 때문에 빠르다. 따라서 소트 부하만 감수한다면, 건건이 버퍼캐시를 경유하는 NL 조인보다 빠르다.
- NL 조인은 조인 컬럼에 대한 인덱스 유무에 크게 영향을 받지만, 소트 머지 조인은 영향을 받지 않는다. 따라서 조인 컬럼에 인덱스가 없는 상황에서 두 테이블을 각각 읽어 조인 대상 집합을 줄일 수 있을 때 아주 유리하다.
- 스캔 위주의 액세스 방식을 사용하지만 모든 처리가 스캔 방식으로 이루어지진 않는다. 양쪽 소스 집합으로부터 조인 대상 레코드를 찾는 데 인덱스를 이용할 수 있고, 그때는 랜덤 액세스가 일어난다.


## 4.3 해시 조인


### 4.3.1 기본 메커니즘
- `해시 조인(Hash Join)`도 소트 머지 조인처럼 두 단계로 진행된다.
    - 1. Build 단계 : 작은 쪽 테이블(Build Input)을 읽어 해시 테이블(해시 맵)을 생성한다.
        - 조인컬럼을 해시 테이블 키 값으로 사용한다.
        - 조인컬럼을 해시 함수에 입력해서 반환된 값으로 해시 체인을 찾고, 그 해시 체인에 데이터를 연결한다.
        - 해시 테이블은 PGA 영역에 할당된 Hash Area에 저장한다.
        - 해시 테이블이 너무 커 PGA에 담을 수 없으면, Temp 테이블스페이스에 저장한다.
    - 2. Probe 단계 : 큰 쪽 테이블(Probe Input)을 읽어 해시 테이블을 탐색하면서 조인한다.
        - 조인할 테이블의 조인 컬럼을 해시 함수에 입력해서 반환된 값으로 해시 체인을 찾고, 그 해시 체인을 스캔해서 값이 같은 조인 컬럼을 찾는다.
        - Build 단계에서 사용한 해시 함수를 Probe 단계에서도 사용하므로 같은 조인 컬럼을 입력하면 같은 해시 값을 반환한다. 따라서 해시 함수가 반환한 값에 해당하는 해시 체인만 스캔하면 된다.
- 해시 조인은 `use_hash` 힌트로 유도한다.


### 4.3.2 해시 조인이 빠른 이유
- Hash Area에 생성한 해시 테이블(=해시 맵)을 이용한다는 점만 다를 뿐 해시 조인도 조인 프로세싱 자체는 NL 조인과 같다. 그런데도 해시 조인이 인덱스 기반의 NL 조인보다 빠른 결정적인 이유는, 소트 머지 조인이 빠른 이유와 같다. 즉, `해시 테이블을 PGA 영역에 할당하기 때문`이다.
- NL 조인은 Outer 테이블 레코드마다 Inner 쪽 테이블 레코드를 읽기 위해 래치 획득 및 캐시버퍼 체인 스캔 과정을 반복하지만, 해시 조인은 래치 획득 과정 없이 PGA에서 빠르게 데이터를 탐색하고 조인한다.
- 해시 조인도 Build Input과 Probe Input 각 테이블을 읽을 때는 DB 버퍼캐시를 경유한다. 이때 인덱스를 이용하기도 한다. 이 과정에서 생기는 버퍼캐시 탐색 비용과 랜덤 액세스 부하는 해시 조인이라도 피할 수 없다.

#### 해시 테이블에 담기는 정보
- 해시 테이블에는 조인 키값뿐만 아니라 SQL에 사용한 컬럼을 모두 저장한다.

#### 해시 조인이 대량 데이터 조인 시 소트 머지 조인보다 빠른 이유
- 두 조인 메소드의 성능 차이는 조인 오퍼레이션을 시작하기 전, 사전 준비작업에 있다.
- 소트 머지 조인에서 사전 준비작업은 `양쪽` 집합을 모두 정렬해서 PGA에 담는 작업이다. PGA는 큰 메모리 공간이 아니므로 두 집합 중 어느 하나가 중대형 이상이면, Temp 테이블스페이스, 즉 디스크에 쓰는 작업을 반드시 수반한다.
- 해시 조인에서 사전 준비작업은 양쪽 집합 중 어느 `한쪽`을 읽어 해시 맵을 만드는 작업이다. 해시 조인은 둘 중 작은 집합을 해시 맵 Build Input으로 선택하므로 두 집합 모두 Hash Area에 담을 수 없을 정도로 큰 경우가 아니면, Temp 테이블스페이스, 즉 디스크에 쓰는 작업은 전혀 일어나지 않는다.
- 정리하면, 해시 조인은 NL 조인처럼 조인 과정에서 발생하는 랜덤 액세스 부하가 없고, 소트 머지 조인처럼 양쪽 집합을 미리 정렬하는 부하도 없다. 해시 테이블을 생성하는 비용이 수반되지만, 둘 중 작은 집합을 Build Input으로 선택하므로 대개는 부담이 크지 않다. Build Input이 PGA에 담길 때, 즉 인메모리(In-Memory) 해시 조인일 때 가장 효과적인 이유가 바로 여기에 있다.


### 4.3.3 대용량 Build Input 처리
- 조인하려는 테이블 2개가 모두 대용량 테이블이어서 인메모리 해시 조인이 불가능한 경우, `분할 정복(Divide & Conquer)` 방식으로 진행한다.
    - 1. 파티션 단계
        - 조인하는 양쪽 집합의 조인 컬럼에 해시 함수를 적용하고, 반환된 해시 값에 따라 동적으로 파티셔닝한다. 독립적으로 처리할 수 있는 여러 개의 작은 서브 집합으로 분할함으로써 파티션 짝(pair)을 생성하는 단계다.
        - 양쪽 집합을 읽어 디스크 Temp 공간에 저장해야 하므로 인메모리 해시 조인보다 성능이 많이 떨어진다.
    - 2. 조인 단계
        - 파티션 단계를 완료하면 각 파티션 짝(pair)에 대해 하나씩 조인을 수행한다. 이때, 각각에 대한 Build Input과 Probe Input은 독립적으로 결정된다.
        - 즉, 파티션하기 전 어느 쪽이 작은 테이블이었는지에 상관없이 각 파티션 짝(pair)별로 작은 쪽을 Build Input으로 선택하고 해시 테이블을 생성한다.
        - 해시 테이블을 생성하고 나면 반대쪽 파티션 로우를 하나씩 읽으면서 해시 테이블을 탐색한다. 모든 파티션 짝에 대한 처리를 마칠 때까지 이 과정을 반복한다.


### 4.3.4 해시 조인 실행계획 제어
- `use_hash` 힌트만 사용하면 `Build Input`을 옵티마이저가 선택하는데, 일반적으로 둘 중 카디널리티가 작은 테이블을 선택한다. (테이블 전체 카디널리티가 아니라 각 테이블 조건절에 대한 카디널리티)
- Build Input을 사용자가 직접 선택하고 싶다면 조인 대상 테이블이 두 개뿐일 경우 `leading`이나 `ordered` 힌트를 사용하면 된다. 
- 오라클은 기본적으로 힌트로 지시한 순서에 따라 가장 먼저 읽는 테이블을 Build Input으로 선택한다.
- `swap_join_inputs` 힌트로 Build Input을 명시적으로 선택할 수도 있다.

#### 세 개 이상 테이블 해시 조인
- 경로1 : A와 B를 조인하고, B와 C를 조인한다.
- 경로2 : A와 B를 조인하고, A와 C를 조인한다.
- 결국 세 테이블을 조인하는 경로는 T1 <-> T2 <-> T3 단 한가지다.
    - 경로1은 A, B, C를 각각 T1, T2, T3에 대입.
    - 경로2는 B, A, C를 각각 T1, T2, T3에 대입.
- T1이 Build Input으로 선택된 상황에서 T2를 Build Input으로 선택하고 싶을 경우, 아래와 같이 `swap_join_inputs` 힌트를 사용하면 된다.
```
SELECT /*+ LEADING(T1, T2, T3) SWAP_JOIN_INPUTS(T2) */ ...
```
- 특정 테이블을 Probe Input으로 선택하고 싶을 경우, `no_swap_join_inputs` 힌트를 사용하면 된다.
```
SELECT /*+ LEADING(T1, T2, T3) NO_SWAP_JOIN_INPUTS(T3) */
```

### 4.3.5 조인 메소드 선택 기준
- 일반적인 메소드 선택 기준은 아래와 같다.
    - 1. 소량 데이터 조인할 때 -> NL 조인
    - 2. 대량 데이터 조인할 때 -> 해시 조인
    - 3. 대량 데이터 조인인데 해시 조인으로 처리할 수 없을 때, 즉 조인 조건식이 등치(=) 조건이 아닐 때(조인 조건식이 아예 없는 카테시안 곱 포함) -> 소트 머지 조인
- 여기서 소량과 대량의 기준은 NL 조인 기준으로 **최적화했는데도** 랜덤 액세스가 많아 만족할만한 성능을 낼 수 없다면, 대량 데이터 조인에 해당한다.
- 수행빈도가 매우 높은 쿼리에 대해서는 아래의 기준이 있다.
    - 1. (최적화된) NL 조인과 해시 조인 성능이 같으면, NL 조인
    - 2. 해시 조인이 약간 더 빨라도 NL 조인
    - 3. NL 조인보다 해시 조인이 매우 빠른 경우, 해시 조인

#### 조인 메소드를 선택할 때 NL 조인을 왜 가장 먼저 고려해야 할까?
- NL 조인에 사용하는 인덱스는 (DBA가 Drop하지 않는 한) 영구적으로 유지하면서 다양한 쿼리를 위해 공유 및 재사용하는 자료구조다.
- 반면, 해시 테이블은 `단 하나의 쿼리를 위해 생성하고 조인이 끝나면 곧바로 소멸하는 자료구조`다. 같은 쿼리를 100개 프로세스가 동시에 수행하면, 해시 테이블도 100개가 만들어진다.
- 따라서 수행시간이 짧으면서 수행빈도 매우 높은 쿼리(대표적으로 OLTP성 쿼리)를 해시 조인으로 처리하면 CPU와 메모리 사용률이 크게 증가한다. 해시 맵을 만드는 과정에 여러 가지 래치 경합도 발생한다.
- 결론적으로 해시 조인은 아래 세 가지 조건을 만족하는 SQL문에 사용한다.
    - 1. 수행 빈도가 낮고
    - 2. 쿼리 수행 시간이 오래 걸리는
    - 3. 대량 데이터 조인할 때
- 위 3가지 조건은 배치 프로그램, DW, OLAP성 쿼리의 특징이기도 하다. OLTP 환경에서도 해시 조인을 쓸 수 있지만, 이 3가지 기준을 만족하는지 점검해 봐야 한다.