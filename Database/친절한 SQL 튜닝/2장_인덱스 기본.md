# 2장 인덱스 기본

## 2.1 인덱스 구조 및 탐색

### 2.1.1 미리 보는 인덱스 튜닝

#### 인덱스 튜닝의 두 가지 핵심요소
- 인덱스는 큰 테이블에서 소량 데이터를 검색할 때 사용한다. (온라인 트랜잭션 처리 Online Transaction Processing, OLTP 등)
- 세부적인 인덱스 튜닝 방법으로 여러 가지가 있지만, 크게 두 가지로 나뉜다.
    - 인덱스 스캔 효율화 튜닝
        - 인덱스 스캔 과정에서 발생하는 비효율을 줄인다.
        - 학생명부에서 시력이 1.0~1.5인 홍길동 학생을 찾는 경우, 학생명부를 이름과 시력순으로 정렬해 두었다면, 소량만 스캔하면 된다.
        - 하지만 학생명부를 시력과 이름순으로 정렬해 두었다면, 똑같이 두 명을 찾는데도 많은 양을 스캔해야 한다.
    - 랜덤 액세스 최소화 튜닝
        - 테이블 액세스 횟수를 줄인다.
        - 학생명부에서 시력이 1.0~1.5인 홍길동 학생을 찾는 경우를 생각해본다. 시력이 1.0~1.5인 학생은 50명이고, 이름이 홍길동인 학생은 5명이다.
        - 만약 이름만으로 정렬한 학생명부와 시력만으로 정렬한 학생명부가 따로 하나씩 있다면 이름순으로 정렬한 학생명부가 효율적이다.

#### SQL 튜닝은 랜덤 I/O와의 전쟁
- 데이터베이스 성능이 느린이유는 디스크 I/O 때문이다. 읽어야 할 데이터량이많고, 그 과정에 디스크 I/O가 많이 발생할 때 느리다. 인덱스를 많이 사용하는 OLTP 시스템이라면 디스크 I/O 중에서도 랜덤 I/O가 특히 중요하다.

### 2.1.2 인덱스 구조
- 데이터베이스에서 인덱스 없이 데이터를 검색하려면, 테이블을 처음부터 끝까지 모두 읽어야 한다. 반면, 인덱스를 이용하면 일부만 읽고 멈출 수 있다. 즉, 범위 스캔(Range Scan)이 가능하다. 범위 스캔이 가능한 이유는 인덱스가 정렬돼 있기 때문이다.
- DBMS는 일반적으로 B*Tree를 사용한다.
- 루트와 브랜치블록에는 키값을 갖지 않는 특별한 레코드가 하나있다. 가장 왼쪽 첫 번째 레코드다. 이를 `LMC`라고 하며, `Leftmost Child`의 줄임말이다. LMC는 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킨다.
- 리프 블록에 저장된 각 레코드는 키값 순으로 정렬돼 있을 뿐만 아니라 테이블 레코드를 가리키는 주소값, 즉 `ROWID`를 갖는다. 인덱스 키값이 같으면 ROWID 순으로 정렬된다.
- 인덱스를 스캔하는 이유는, 검색 조건을 만족하는 소량의 데이터를 빨리 찾고 거기서 ROWID를 얻기 위해서다.
    - ROWID = 데이터 블록 주소 + 로우 번호(블록 내 순번)
    - 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호(데이터파일 내에서 부여한 상대적 순번)
- 인덱스 탐색 과정은 수직적 탐색과 수평적 탐색으로 나눌 수 있다.
    - 수직적 탐색 : 인덱스 스캔 시작지점을 찾는 과정
    - 수평적 탐색 : 데이터를 찾는 과정

### 2.1.3 인덱스 수직적 탐색
- 정렬된 인덱스 레코드 중 조건을 만족하는 첫 번째 레코드를 찾는 과정이다. 즉, **인덱스 스캔 시작지점을 찾는 과정**이다.
- 인덱스 수직적 탐색은 루트(Root) 블록에서부터 시작한다. 루트를 포함해 브랜치(Branch) 블록에 저장된 각 인덱스 레코드는 하위 블록에 대한 주소값을 갖는다. 루트에서 시작해 리프(Leaf) 블록까지 수직적 탐색이 가능한 이유다.
- 인덱스를 수직적으로 탐색할 때, 루트를 포함한 브랜치 블록은 등산 푯말과 같은 역할을 한다. '조건을 만족하는 첫 번째 레코드'가 목표지점이다. 푯말이 알려주는 대로 따라가다 보면 '조건을 만족하는 첫 번째 레코드'를 만날 수 있다.

### 2.1.4 인덱스 수평적 탐색
- 수직적 탐색을 통해 스캔 시작점을 찾았으면, 찾고자 하는데이터가 더 안 나타낼 때까지 인덱스 리프 블록을 수평적으로 스캔한다. 인덱스에서 본격적으로 **데이터를 찾는 과정**이다.
- 인덱스 리프 블록끼리는 서로 앞뒤 블록에 대한 주소값을 갖는다. 즉, 양방향 연결 리스트(double linked list) 구조다.
- 인덱스를 수평적으로 탐색하는 이유는 첫째, 조건절을 만족하는 데이터를 모두 찾기 위해서고 둘째, ROWID를 얻기 위해서다. 필요한 컬럼을 인덱스가 모두 갖고 있어 인덱스만 스캔하고 끝나는 경우도 있지만, 일반적으로 인덱스를 스캔하고서 테이블도 액세스한다. 이때 ROWID가 필요하다.

### 2.1.5 결합 인덱스 구조와 탐색
- 두 개 이상 컬럼을 결합해서 인덱스를 만들 수도 있다. (결합 인덱스 탐색 과정은 책 79P 참고)
- 인덱스를 [고객명 + 성별]로 구성하든, [성별 + 고객명]으로 구성하든 읽는 인덱스 블록 개수가 똑같다.
- **인덱스 선두 컬럼을 모두 "=" 조건으로 검색할 때**는 어느 컬럼을 인덱스 앞쪽에 두든 블록 I/O 개수가 같으므로 성능도 똑같다.

## 2.2 인덱스 기본사용법
### 2.2.1 인덱스를 사용한다는 것
- 인덱스 컬럼(정확히 말하면, 선두 컬럼)을 가공하지 않아야 인덱스를 정상적으로 사용할 수 있다.
- '인덱스를 정상적으로 사용한다'는 표현은 리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미한다. 즉 리프 블록 일부만 스캔하는 `Index Range Scan`을 의미한다.
- 인덱스 컬럼을 가공해도 인덱스를 사용할 수는 있지만, 스캔 시작점을 찾을 수 없고 멈출 수도 없어 리프 블록 전체를 스캔해야만 한다. 즉, 일부가 아닌 전체를 스캔하는 `Index Full Scan` 방식으로 동작한다.

### 2.2.2 인덱스를 Range Scan 할 수 없는 이유
```
"인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용(Range Scan)할 수 없다."
```
- 인덱스 컬럼을 가공했을 때 인덱스를 정상적으로 사용할 수 없는 이유는 **인덱스 스캔 시작점을 찾을 수 없기 때문**이다. Index Range Scan은 인덱스에서 일정 범위를 스캔한다는 뜻인데, 일정 범위를 스캔한다면 '시작점'과 '끝지점'이 있어야 한다.
- 예를 들어, 어느 초등학교에서 1학년부터 6학년까지 전교생을 생년월일 순으로 학교 운동장에 줄 세웠다. 여기서 2007년 1월에 태어난 학생을 찾으려면, 우선 2007년 1월 1일 이후에 태어난 첫 번째 학생을 찾고, 거기서부터 순서대로 스캔하다가 2007년 2월 1일 이후에 태어난 첫 번째 학생을 만나는 순간 멈추면 된다. 분명한 시작점과 끝지점이 있다.
- 아래의 조건절을 처리할 때도 시작점과 끝지점이 분명하다.
```
where 생년월일 between '20070101` and '20070131'
```

- 이번에는 년도와 상관없이 5월에 태어난 학생을 찾아보자. 스캔 시작지점과 종료지점을 알 수 없다. 전교생을 다 스캔해야만 한다.
- 아래의 조건절을 처리할 때도 같은 문제에 직면한다.
```
where substr(생년월일, 5, 2) = '05'
```
- 아래의 조건절도 마찬가지다. 가공하지 않은 주문수량으로 인덱스를 만들었는데, '값이 NULL이면 0으로 치환한 값' 기준으로 100보다 작은 레코드를 찾아달라고 쿼리를 작성하면 인덱스 스캔 시작지점을 찾을수가 없다.
```
where nvl(주문수량, 0) < 100
```

- 아래와 같이 LIKE로 중간 값을 검색할 때도 마찬가지다. '대한'으로 시작하는 값은 특정 구간에 모여 있으므로 Range Scan이 가능하지만, '대한'을 포함하는 값은 전체 구간에 걸쳐 흩어져 있어 Range Scan이 불가능하다.
```
where 업체명 like '%대한%'
```

- 아래와 같이 OR 조건으로 검색할 때, 수직적 탐색을 통해 전화번호가 '01012345678'이거나 고객명이 '홍길동'인 어느 한 시작지점을 바로 찾을 수 없다. 따라서 인덱스를 어떤 방식으로 수행해도 Range Scan 할 수 없다.
```
where (전화번호 = :tel_no OR 고객명 = :cust_nm)
```

- 아래와 같은 IN 조건절도 OR 조건을 표현하는 다른 방식일 뿐이다.
```
where 전화번호 in (:tel_no1, :tel_no2)
```

- 하지만 아래와 같이 SQL을 UNION ALL 방식으로 작성하면 각 브랜치 별로 인덱스 스캔 시작점을 찾을 수 있어 Range Scan이 가능하다.
```
select *
from 고객
where 전화번호 = :tel_no1
union all
select *
from 고객
where 전화번호 = "tel_no2
```

- 그래서 IN 조건절에 대해서는 SQL 옵티마이저가 IN-List Iterator 방식을 사용한다. IN-List 개수만큼 Index Range Scan을 반복하는 것이다. 이를 통해 SQL을 UNION ALL 방식으로 변환한 것과 같은 효과를 얻을 수 있다.
- 정리하면, **인덱스를 정상적으로 사용한다**는 표현은 리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미한다. 아래와 같은 조건절에는 인덱스를 정상적으로 사용할 수 없다. 기본적으로 Index Range Scan이 불가능하다. 단, OR 또는 IN 조건절은 옵티마이저의 쿼리변환 기능을 통해 Index Range Scan으로 처리되기도 한다.
```
where substr(생년월일, 5, 2) = '05'
where nvl(주문수량, 0) < 100
where 업체명 like '%대한%'
where (전화번호 = :tel_no1 or 고객명 = :cust_nm)
where 전화번호 in (:tel_no1, :tel_no2)
```

### 2.2.3 더 중요한 인덱스 사용 조건
- 인덱스를 `소속팀 + 사원명 + 연령` 순으로 구성해보자. **데이터를 소속팀 순으로 정렬하고, 소속팀이 같으면 사원명 순으로 정렬하고, 사원명까지 같으면 연령 순으로 정렬한다**는 의미다. 그렇다면 이름이 같은 사원이라도 소속팀이 다르면 서로 멀리 떨어지게 된다.
- 인덱스를 Range Scan 하기 위한 가장 첫 번째 조건은 인덱스 선두 컬럼이 가공하지 않은 상태로 조건절에 있어야 한다.
```
TXA1234_IX02 인덱스 : 기준연도 + 과세구분코드 + 보고회차 + 실명확인번호

select * from TXA1234
where 기준년도 = :stdr_year
and substr(과세구분코드, 1, 4) = :txtn_dcd
and 보고회사 = :rpt_tmrd
and 실명확인번호 = :rnm_cnfm_no
```
- 위 SQL은 인덱스 컬럼을 가공했는데, 어떻게 인덱스를 Range Scan 할 수 있는가?
- 인덱스 선두 컬럼인 `기준연도`를 조건절에서 가공하지 않았으므로 인덱스 Range Scan이 가능하다.
- 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면 인덱스 Range Scan은 무조건 가능하다.

#### 인덱스 컬럼 가공 예시
```
(튜닝 전)
select * from 업체
where substr(업체명, 1, 2) = '대한';

(튜닝 후)
select * from 업체
where 업체명 like '대한%';
```
```
(튜닝 전)
select * from 사원
where 월급여 * 12 = 36000000;

(튜닝 후)
select * from 사원
where 월급여 = 36000000 / 12;
```
```
(튜닝 전)
select * from 주문
where to_char(일시, 'yyyymmdd') = :dt;

(튜닝 후)
select * from 주문
where 일시 >= to_date(:dt, 'yyyymmdd') and 일시 < to_date(:dt, 'yyyymmdd') + 1;
```
```
(튜닝 전)
select * from 고객
where 연령 || 직업 = '30공무원';

(튜닝 후)
select * from 고객
where 연령 = 30 and 직업 = '공무원';
```
```
(튜닝 전)
select * from 회원사지점
where 회원번호 || 지점번호 = :str;

(튜닝 후)
select * from 회원사지점
where 회원번호 = substr(:str, 1, 2) and 지점번호 = substr(:str, 3, 4);
```
```
(튜닝 전)
select * from 주문
where nvl(주문수량, 0) >= 100;

* nvl 때문에 인덱스를 활용하지 않음.

(튜닝 후)
select * from 주문
where 주문수량 >= 100;
```
```
(튜닝 전)
select * from 주문
where nvl(주문수량, 0) < 100;

(튜닝 후)
* 주문수량이 NOT NULL이 아니면 수정.
함수기반 인덱스(FBI) 생성 고려 -> create index 주문_x01 on 주문(nvl(주문수량, 0));
```
- 인덱스를 Range Scan 한다고 해서 항상 성능이 좋은 건 아니다.

#### 인덱스 잘 타니까 튜닝 끝?
- 주문상품_N1 인덱스가 `주문일자 + 상품번호`순으로 구성됐고, 이 테이블에 쌓이는 데이터량은 하루 평균 100만건이라고 가정하자.
```
SELECT *
FROM 주문상품
WHERE 주문일자 = :ORD_DT
AND   상품번호 LIKE '%PING%' ;

SELECT *
FROM 주문상품
WHERE 주문일자 = :ORD_DT
AND   SUBSTR(상품번호, 1, 4) = 'PING' ;
```
- 위 조건절은 인덱스 선두 컬럼인 주문일자가 조건절에 있고, 가공하지 않은 상태이므로 인덱스를 Range Scan 하는 데 문제가 없다. 그런데 인덱스를 정말 잘 타는지는 인덱스 리프 블록에서 스캔하는 양을 따져봐야 알 수 있다.
- 위 SQL에서 상품번호는 스캔 범위를 줄이는 데 전혀 역할을 하지 못한다. 첫 번째 SQL은 중간 값 검색이기 때문이고, 두 번째 SQL은 컬럼을 가공했기 때문이다. 따라서 위 조건절을 처리할 때 인덱스에서 스캔하는 데이터량은 주문일자 조건을 만족하는 100만 건이다.
- 이를 두고, 인덱스를 잘 탄다고 말할 수 있을까? 

### 2.2.4 인덱스를 이용한 소트 연산 생략
- PK를 `장비번호 + 변경일자 + 변경순번` 순으로구성한 상태변경이력 테이블이 있다고 하자. PK 인덱스에서 장비번호, 변경일자가 같은 레코드는 변경순번 순으로 정렬돼 있다.
- 장비번호와 변경일자를 모두 '=' 조건으로 검색할 때 PK 인덱스를 사용하면 결과집합은 변경순번 순으로 출력된다.
- 이럴 경우, 옵티마이저는 SQL에 ORDER BY가 있어도 정렬 연산을 따로 수행하지 않는다. PK 인덱스를 스캔하면서 출력한 결과집합은 어차피 변경순번 순으로 정렬되기 때문이다.
- 만약 정렬 연산을 생략할 수 있게 인덱스가 구성돼 있지 않다면, SORT ORDER BY 연산 단계가 추가된다.
- 내림차순(Desc) 정렬에도 인덱스를 활용할 수 있다. 왜냐하면 인덱스 리프 블록은 양방향 연결 리스트 구조이기 때문이다.
- 오름차순(Asc) 정렬일 때는 조건을 만족하는 가장 작은 값을 찾아 좌측으로 수직적 탐색한 후 우측으로 수평적 탐색을 한다.
- 내림차순 정렬일 때는 조건을 만족하는 가장 큰 값을 찾아 우측으로 수직적 탐색한 후 좌측으로 수평적 탐색을 한다.
- SQL에 ORDER BY절에서 내림차순을 요구할 경우 실행계획에 SORT ORDER BY 연산은 없지만, INDEX RANGE SCAN 단계에 DESCENDING을 확인할 수 있다.

### 2.2.5 ORDER BY 절에서 컬럼 가공
- "**인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다**"에서 말하는 **인덱스 컬럼**은 대개 조건절에 사용한 컬럼을 말한다. 그런데 조건절이 아닌 ORDER BY 또는 SELECT-LIST에서 컬럼을 가공함으로 인해 인덱스를 정상적으로 사용할 수 없는 경우도 종종 있다.

```
SELECT *
FROM 상태변경이력
WHERE 장비번호 = 'C'
ORDER BY 변경일자, 변경순번
```
- 상태변경이력 PK 인덱스를 `장비번호 + 변경일자 + 변경순번` 순으로 구성했다면 위 SQL도 정렬 연산을 생략할 수 있다.

```
SELECT *
FROM 상태변경이력
WHERE 장비번호 = 'C'
ORDER BY 변경일자 || 변경순번
```
- 만약 개발자가 SQL을 위와 같이 작성했다면, 정렬 연산을 생략할 수 없다. 인덱스에는 가공하지 않은 상태로 값을 저장했는데, 가공한 값 기준으로 정렬해 달라고 요청했기 때문이다.

```
SELECT *
FROM (
    SELECT TO_CHAR(A.주문번호, 'FM000000') AS 주문번호, A.업체번호, A.주문금액
    FROM 주문 A
    WHERE A.주문일자 = :dt
    AND A.주문번호 > NVL(:next_order_no, 0)
    ORDER BY 주문번호
)
WHERE ROWNUM <= 30
```
- 주문_PK 인덱스는 `주문일자 + 주문번호` 순으로 구성돼 있다. 위의 SQL에 주문_PK 인덱스를 사용하면 선두 컬럼인 주문일자가 '=' 조건이므로 데이터가 주문번호 순으로 출력된다. ORDER BY 절이 있어도 정렬 연산을 생략할 수 있는 상태다.
- 하지만 실행 계획에서는 SORT ORDER BY 연산이 나타나고 있다. 왜냐하면 ORDER BY 절에 기술한 '주문번호'는 순수한 주문번호가 아니라 TO_CHAR 함수로 가공한 주문번호를 가리키기 때문이다.

```
SELECT *
FROM (
    SELECT TO_CHAR(A.주문번호, 'FM000000') AS 주문번호, A.업체번호, A.주문금액
    FROM 주문 A
    WHERE A.주문일자 = :dt
    AND A.주문번호 > NVL(:next_order_no, 0)
    ORDER BY A.주문번호
)
WHERE ROWNUM <= 30
```
- 해결방법은 간단하다. 위와 같이 ORDER BY 절 주문번호에 A(주문 테이블 Alias)를 붙여주기만 하면 된다.

## 2.3 인덱스 확장기능 사용법