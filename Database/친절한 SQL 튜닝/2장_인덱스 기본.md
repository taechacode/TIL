# 2장 인덱스 기본

## 2.1 인덱스 구조 및 탐색

### 2.1.1 미리 보는 인덱스 튜닝

#### 인덱스 튜닝의 두 가지 핵심요소
- 인덱스는 큰 테이블에서 소량 데이터를 검색할 때 사용한다. (온라인 트랜잭션 처리 Online Transaction Processing, OLTP 등)
- 세부적인 인덱스 튜닝 방법으로 여러 가지가 있지만, 크게 두 가지로 나뉜다.
    - 인덱스 스캔 효율화 튜닝
        - 인덱스 스캔 과정에서 발생하는 비효율을 줄인다.
        - 학생명부에서 시력이 1.0~1.5인 홍길동 학생을 찾는 경우, 학생명부를 이름과 시력순으로 정렬해 두었다면, 소량만 스캔하면 된다.
        - 하지만 학생명부를 시력과 이름순으로 정렬해 두었다면, 똑같이 두 명을 찾는데도 많은 양을 스캔해야 한다.
    - 랜덤 액세스 최소화 튜닝
        - 테이블 액세스 횟수를 줄인다.
        - 학생명부에서 시력이 1.0~1.5인 홍길동 학생을 찾는 경우를 생각해본다. 시력이 1.0~1.5인 학생은 50명이고, 이름이 홍길동인 학생은 5명이다.
        - 만약 이름만으로 정렬한 학생명부와 시력만으로 정렬한 학생명부가 따로 하나씩 있다면 이름순으로 정렬한 학생명부가 효율적이다.

#### SQL 튜닝은 랜덤 I/O와의 전쟁
- 데이터베이스 성능이 느린이유는 디스크 I/O 때문이다. 읽어야 할 데이터량이 많고, 그 과정에 디스크 I/O가 많이 발생할 때 느리다. 인덱스를 많이 사용하는 OLTP 시스템이라면 디스크 I/O 중에서도 랜덤 I/O가 특히 중요하다.

### 2.1.2 인덱스 구조
- 데이터베이스에서 인덱스 없이 데이터를 검색하려면, 테이블을 처음부터 끝까지 모두 읽어야 한다. 반면, 인덱스를 이용하면 일부만 읽고 멈출 수 있다. 즉, 범위 스캔(Range Scan)이 가능하다. 범위 스캔이 가능한 이유는 인덱스가 정렬돼 있기 때문이다.
- DBMS는 일반적으로 B*Tree를 사용한다.
- 루트와 브랜치블록에는 키값을 갖지 않는 특별한 레코드가 하나있다. 가장 왼쪽 첫 번째 레코드다. 이를 `LMC`라고 하며, `Leftmost Child`의 줄임말이다. LMC는 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킨다.
- 리프 블록에 저장된 각 레코드는 키값 순으로 정렬돼 있을 뿐만 아니라 테이블 레코드를 가리키는 주소값, 즉 `ROWID`를 갖는다. 인덱스 키값이 같으면 ROWID 순으로 정렬된다.
- 인덱스를 스캔하는 이유는, 검색 조건을 만족하는 소량의 데이터를 빨리 찾고 거기서 ROWID를 얻기 위해서다.
    - ROWID = 데이터 블록 주소 + 로우 번호(블록 내 순번)
    - 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호(데이터파일 내에서 부여한 상대적 순번)
- 인덱스 탐색 과정은 수직적 탐색과 수평적 탐색으로 나눌 수 있다.
    - 수직적 탐색 : 인덱스 스캔 시작지점을 찾는 과정
    - 수평적 탐색 : 데이터를 찾는 과정

### 2.1.3 인덱스 수직적 탐색
- 정렬된 인덱스 레코드 중 조건을 만족하는 첫 번째 레코드를 찾는 과정이다. 즉, **인덱스 스캔 시작지점을 찾는 과정**이다.
- 인덱스 수직적 탐색은 루트(Root) 블록에서부터 시작한다. 루트를 포함해 브랜치(Branch) 블록에 저장된 각 인덱스 레코드는 하위 블록에 대한 주소값을 갖는다. 루트에서 시작해 리프(Leaf) 블록까지 수직적 탐색이 가능한 이유다.
- 인덱스를 수직적으로 탐색할 때, 루트를 포함한 브랜치 블록은 등산 푯말과 같은 역할을 한다. '조건을 만족하는 첫 번째 레코드'가 목표지점이다. 푯말이 알려주는 대로 따라가다 보면 '조건을 만족하는 첫 번째 레코드'를 만날 수 있다.

### 2.1.4 인덱스 수평적 탐색
- 수직적 탐색을 통해 스캔 시작점을 찾았으면, 찾고자 하는데이터가 더 안 나타낼 때까지 인덱스 리프 블록을 수평적으로 스캔한다. 인덱스에서 본격적으로 **데이터를 찾는 과정**이다.
- 인덱스 리프 블록끼리는 서로 앞뒤 블록에 대한 주소값을 갖는다. 즉, 양방향 연결 리스트(double linked list) 구조다.
- 인덱스를 수평적으로 탐색하는 이유는 첫째, 조건절을 만족하는 데이터를 모두 찾기 위해서고 둘째, ROWID를 얻기 위해서다. 필요한 컬럼을 인덱스가 모두 갖고 있어 인덱스만 스캔하고 끝나는 경우도 있지만, 일반적으로 인덱스를 스캔하고서 테이블도 액세스한다. 이때 ROWID가 필요하다.

### 2.1.5 결합 인덱스 구조와 탐색
- 두 개 이상 컬럼을 결합해서 인덱스를 만들 수도 있다. (결합 인덱스 탐색 과정은 책 79P 참고)
- 인덱스를 [고객명 + 성별]로 구성하든, [성별 + 고객명]으로 구성하든 읽는 인덱스 블록 개수가 똑같다.
- **인덱스 선두 컬럼을 모두 "=" 조건으로 검색할 때**는 어느 컬럼을 인덱스 앞쪽에 두든 블록 I/O 개수가 같으므로 성능도 똑같다.

## 2.2 인덱스 기본사용법
### 2.2.1 인덱스를 사용한다는 것
- 인덱스 컬럼(정확히 말하면, 선두 컬럼)을 가공하지 않아야 인덱스를 정상적으로 사용할 수 있다.
- '인덱스를 정상적으로 사용한다'는 표현은 리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미한다. 즉 리프 블록 일부만 스캔하는 `Index Range Scan`을 의미한다.
- 인덱스 컬럼을 가공해도 인덱스를 사용할 수는 있지만, 스캔 시작점을 찾을 수 없고 멈출 수도 없어 리프 블록 전체를 스캔해야만 한다. 즉, 일부가 아닌 전체를 스캔하는 `Index Full Scan` 방식으로 동작한다.

### 2.2.2 인덱스를 Range Scan 할 수 없는 이유
```
"인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용(Range Scan)할 수 없다."
```
- 인덱스 컬럼을 가공했을 때 인덱스를 정상적으로 사용할 수 없는 이유는 **인덱스 스캔 시작점을 찾을 수 없기 때문**이다. Index Range Scan은 인덱스에서 일정 범위를 스캔한다는 뜻인데, 일정 범위를 스캔한다면 '시작점'과 '끝지점'이 있어야 한다.
- 예를 들어, 어느 초등학교에서 1학년부터 6학년까지 전교생을 생년월일 순으로 학교 운동장에 줄 세웠다. 여기서 2007년 1월에 태어난 학생을 찾으려면, 우선 2007년 1월 1일 이후에 태어난 첫 번째 학생을 찾고, 거기서부터 순서대로 스캔하다가 2007년 2월 1일 이후에 태어난 첫 번째 학생을 만나는 순간 멈추면 된다. 분명한 시작점과 끝지점이 있다.
- 아래의 조건절을 처리할 때도 시작점과 끝지점이 분명하다.
```
where 생년월일 between '20070101` and '20070131'
```

- 이번에는 년도와 상관없이 5월에 태어난 학생을 찾아보자. 스캔 시작지점과 종료지점을 알 수 없다. 전교생을 다 스캔해야만 한다.
- 아래의 조건절을 처리할 때도 같은 문제에 직면한다.
```
where substr(생년월일, 5, 2) = '05'
```
- 아래의 조건절도 마찬가지다. 가공하지 않은 주문수량으로 인덱스를 만들었는데, '값이 NULL이면 0으로 치환한 값' 기준으로 100보다 작은 레코드를 찾아달라고 쿼리를 작성하면 인덱스 스캔 시작지점을 찾을수가 없다.
```
where nvl(주문수량, 0) < 100
```

- 아래와 같이 LIKE로 중간 값을 검색할 때도 마찬가지다. '대한'으로 시작하는 값은 특정 구간에 모여 있으므로 Range Scan이 가능하지만, '대한'을 포함하는 값은 전체 구간에 걸쳐 흩어져 있어 Range Scan이 불가능하다.
```
where 업체명 like '%대한%'
```

- 아래와 같이 OR 조건으로 검색할 때, 수직적 탐색을 통해 전화번호가 '01012345678'이거나 고객명이 '홍길동'인 어느 한 시작지점을 바로 찾을 수 없다. 따라서 인덱스를 어떤 방식으로 수행해도 Range Scan 할 수 없다.
```
where (전화번호 = :tel_no OR 고객명 = :cust_nm)
```

- 아래와 같은 IN 조건절도 OR 조건을 표현하는 다른 방식일 뿐이다.
```
where 전화번호 in (:tel_no1, :tel_no2)
```

- 하지만 아래와 같이 SQL을 UNION ALL 방식으로 작성하면 각 브랜치 별로 인덱스 스캔 시작점을 찾을 수 있어 Range Scan이 가능하다.
```
select *
from 고객
where 전화번호 = :tel_no1
union all
select *
from 고객
where 전화번호 = "tel_no2
```

- 그래서 IN 조건절에 대해서는 SQL 옵티마이저가 IN-List Iterator 방식을 사용한다. IN-List 개수만큼 Index Range Scan을 반복하는 것이다. 이를 통해 SQL을 UNION ALL 방식으로 변환한 것과 같은 효과를 얻을 수 있다.
- 정리하면, **인덱스를 정상적으로 사용한다**는 표현은 리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미한다. 아래와 같은 조건절에는 인덱스를 정상적으로 사용할 수 없다. 기본적으로 Index Range Scan이 불가능하다. 단, OR 또는 IN 조건절은 옵티마이저의 쿼리변환 기능을 통해 Index Range Scan으로 처리되기도 한다.
```
where substr(생년월일, 5, 2) = '05'
where nvl(주문수량, 0) < 100
where 업체명 like '%대한%'
where (전화번호 = :tel_no1 or 고객명 = :cust_nm)
where 전화번호 in (:tel_no1, :tel_no2)
```

### 2.2.3 더 중요한 인덱스 사용 조건
- 인덱스를 `소속팀 + 사원명 + 연령` 순으로 구성해보자. **데이터를 소속팀 순으로 정렬하고, 소속팀이 같으면 사원명 순으로 정렬하고, 사원명까지 같으면 연령 순으로 정렬한다**는 의미다. 그렇다면 이름이 같은 사원이라도 소속팀이 다르면 서로 멀리 떨어지게 된다.
- 인덱스를 Range Scan 하기 위한 가장 첫 번째 조건은 인덱스 선두 컬럼이 가공하지 않은 상태로 조건절에 있어야 한다.
```
TXA1234_IX02 인덱스 : 기준연도 + 과세구분코드 + 보고회차 + 실명확인번호

select * from TXA1234
where 기준년도 = :stdr_year
and substr(과세구분코드, 1, 4) = :txtn_dcd
and 보고회사 = :rpt_tmrd
and 실명확인번호 = :rnm_cnfm_no
```
- 위 SQL은 인덱스 컬럼을 가공했는데, 어떻게 인덱스를 Range Scan 할 수 있는가?
- 인덱스 선두 컬럼인 `기준연도`를 조건절에서 가공하지 않았으므로 인덱스 Range Scan이 가능하다.
- 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면 인덱스 Range Scan은 무조건 가능하다.

#### 인덱스 컬럼 가공 예시
```
(튜닝 전)
select * from 업체
where substr(업체명, 1, 2) = '대한';

(튜닝 후)
select * from 업체
where 업체명 like '대한%';
```
```
(튜닝 전)
select * from 사원
where 월급여 * 12 = 36000000;

(튜닝 후)
select * from 사원
where 월급여 = 36000000 / 12;
```
```
(튜닝 전)
select * from 주문
where to_char(일시, 'yyyymmdd') = :dt;

(튜닝 후)
select * from 주문
where 일시 >= to_date(:dt, 'yyyymmdd') and 일시 < to_date(:dt, 'yyyymmdd') + 1;
```
```
(튜닝 전)
select * from 고객
where 연령 || 직업 = '30공무원';

(튜닝 후)
select * from 고객
where 연령 = 30 and 직업 = '공무원';
```
```
(튜닝 전)
select * from 회원사지점
where 회원번호 || 지점번호 = :str;

(튜닝 후)
select * from 회원사지점
where 회원번호 = substr(:str, 1, 2) and 지점번호 = substr(:str, 3, 4);
```
```
(튜닝 전)
select * from 주문
where nvl(주문수량, 0) >= 100;

* nvl 때문에 인덱스를 활용하지 않음.

(튜닝 후)
select * from 주문
where 주문수량 >= 100;
```
```
(튜닝 전)
select * from 주문
where nvl(주문수량, 0) < 100;

(튜닝 후)
* 주문수량이 NOT NULL이 아니면 수정.
함수기반 인덱스(FBI) 생성 고려 -> create index 주문_x01 on 주문(nvl(주문수량, 0));
```
- 인덱스를 Range Scan 한다고 해서 항상 성능이 좋은 건 아니다.

#### 인덱스 잘 타니까 튜닝 끝?
- 주문상품_N1 인덱스가 `주문일자 + 상품번호`순으로 구성됐고, 이 테이블에 쌓이는 데이터량은 하루 평균 100만건이라고 가정하자.
```
SELECT *
FROM 주문상품
WHERE 주문일자 = :ORD_DT
AND   상품번호 LIKE '%PING%' ;

SELECT *
FROM 주문상품
WHERE 주문일자 = :ORD_DT
AND   SUBSTR(상품번호, 1, 4) = 'PING' ;
```
- 위 조건절은 인덱스 선두 컬럼인 주문일자가 조건절에 있고, 가공하지 않은 상태이므로 인덱스를 Range Scan 하는 데 문제가 없다. 그런데 인덱스를 정말 잘 타는지는 인덱스 리프 블록에서 스캔하는 양을 따져봐야 알 수 있다.
- 위 SQL에서 상품번호는 스캔 범위를 줄이는 데 전혀 역할을 하지 못한다. 첫 번째 SQL은 중간 값 검색이기 때문이고, 두 번째 SQL은 컬럼을 가공했기 때문이다. 따라서 위 조건절을 처리할 때 인덱스에서 스캔하는 데이터량은 주문일자 조건을 만족하는 100만 건이다.
- 이를 두고, 인덱스를 잘 탄다고 말할 수 있을까? 

### 2.2.4 인덱스를 이용한 소트 연산 생략
- PK를 `장비번호 + 변경일자 + 변경순번` 순으로 구성한 상태변경이력 테이블이 있다고 하자. PK 인덱스에서 장비번호, 변경일자가 같은 레코드는 변경순번 순으로 정렬돼 있다.
- 장비번호와 변경일자를 모두 '=' 조건으로 검색할 때 PK 인덱스를 사용하면 결과집합은 변경순번 순으로 출력된다.
- 이럴 경우, 옵티마이저는 SQL에 ORDER BY가 있어도 정렬 연산을 따로 수행하지 않는다. PK 인덱스를 스캔하면서 출력한 결과집합은 어차피 변경순번 순으로 정렬되기 때문이다.
- 만약 정렬 연산을 생략할 수 있게 인덱스가 구성돼 있지 않다면, SORT ORDER BY 연산 단계가 추가된다.
- 내림차순(Desc) 정렬에도 인덱스를 활용할 수 있다. 왜냐하면 인덱스 리프 블록은 양방향 연결 리스트 구조이기 때문이다.
- 오름차순(Asc) 정렬일 때는 조건을 만족하는 가장 작은 값을 찾아 좌측으로 수직적 탐색한 후 우측으로 수평적 탐색을 한다.
- 내림차순 정렬일 때는 조건을 만족하는 가장 큰 값을 찾아 우측으로 수직적 탐색한 후 좌측으로 수평적 탐색을 한다.
- SQL에 ORDER BY절에서 내림차순을 요구할 경우 실행계획에 SORT ORDER BY 연산은 없지만, INDEX RANGE SCAN 단계에 DESCENDING을 확인할 수 있다.

### 2.2.5 ORDER BY 절에서 컬럼 가공
- "**인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다**"에서 말하는 **인덱스 컬럼**은 대개 조건절에 사용한 컬럼을 말한다. 그런데 조건절이 아닌 ORDER BY 또는 SELECT-LIST에서 컬럼을 가공함으로 인해 인덱스를 정상적으로 사용할 수 없는 경우도 종종 있다.

```
SELECT *
FROM 상태변경이력
WHERE 장비번호 = 'C'
ORDER BY 변경일자, 변경순번
```
- 상태변경이력 PK 인덱스를 `장비번호 + 변경일자 + 변경순번` 순으로 구성했다면 위 SQL도 정렬 연산을 생략할 수 있다.

```
SELECT *
FROM 상태변경이력
WHERE 장비번호 = 'C'
ORDER BY 변경일자 || 변경순번
```
- 만약 개발자가 SQL을 위와 같이 작성했다면, 정렬 연산을 생략할 수 없다. 인덱스에는 가공하지 않은 상태로 값을 저장했는데, 가공한 값 기준으로 정렬해 달라고 요청했기 때문이다.

```
SELECT *
FROM (
    SELECT TO_CHAR(A.주문번호, 'FM000000') AS 주문번호, A.업체번호, A.주문금액
    FROM 주문 A
    WHERE A.주문일자 = :dt
    AND A.주문번호 > NVL(:next_order_no, 0)
    ORDER BY 주문번호
)
WHERE ROWNUM <= 30
```
- 주문_PK 인덱스는 `주문일자 + 주문번호` 순으로 구성돼 있다. 위의 SQL에 주문_PK 인덱스를 사용하면 선두 컬럼인 주문일자가 '=' 조건이므로 데이터가 주문번호 순으로 출력된다. ORDER BY 절이 있어도 정렬 연산을 생략할 수 있는 상태다.
- 하지만 실행 계획에서는 SORT ORDER BY 연산이 나타나고 있다. 왜냐하면 ORDER BY 절에 기술한 '주문번호'는 순수한 주문번호가 아니라 TO_CHAR 함수로 가공한 주문번호를 가리키기 때문이다.

```
SELECT *
FROM (
    SELECT TO_CHAR(A.주문번호, 'FM000000') AS 주문번호, A.업체번호, A.주문금액
    FROM 주문 A
    WHERE A.주문일자 = :dt
    AND A.주문번호 > NVL(:next_order_no, 0)
    ORDER BY A.주문번호
)
WHERE ROWNUM <= 30
```
- 해결방법은 간단하다. 위와 같이 ORDER BY 절 주문번호에 A(주문 테이블 Alias)를 붙여주기만 하면 된다.

### 2.2.6 SELECT-LIST에서 컬럼 가공
- 인덱스를 `장비번호 + 변경일자 + 변경순번` 순으로 구성하면, 아래와 같이 변경순번 최소값을 구할 때도 옵티마이저는 정렬 연산을 따로 수행하지 않는다. 수직적 탐색을 통해 조건을 만족하는 가장 왼쪽 지점으로 내려가서 첫 번째 읽는 레코드가 바로 최소값이기 때문이다.
```
SELECT MIN(변경순번)
FROM   상태변경이력
WHERE  장비번호 = 'C'
AND    변경일자 = '20180316'
```

- 아래와 같이 변경순번 최대값을 구할 때도 정렬 연산을 수행하지 않는다. 최소값을 찾아 수직적 탐색할 때 왼쪽으로 내려갔다면, 최대값을 찾을 때는 오른쪽으로 내려가는 점만 다르다.
- 수직점 탐색을 통해 조건을 만족하는 가장 오른쪽 지점으로 내려가서 첫 번째 읽는 레코드가 바로 최대값이다.
```
SELECT MAX(변경순번)
FROM   상태변경이력
WHERE  장비번호 = 'C'
AND    변경일자 = '20180316'
```

- 인덱스를 이용해 정렬 연산 없이 최소 또는 최대값을 빠르게 찾을 때 인덱스 리프 블록의 왼쪽(MIN) 또는 오른쪽(MAX)에서 레코드 하나(FIRST ROW)만 읽고 멈춘다.
- 그런데 SQL을 아래와 같이 작성하면 정렬 연산을 생략할 수 없다. 인덱스에는 문자열 기준으로 정렬돼 있는데, 이를 숫자값으로 바꾼 값 기준으로 최종 변경순번을 요구했기 때문이다.
```
SELECT NVL(MAX(TO_NUMBER(변경순번)), 0)
FROM   상태변경이력
WHERE  장비번호 = 'C'
AND    변경일자 = '20180316'
```

- SQL을 아래와 같이 바꾸면 정렬 연산 없이 최종 변경순번을 쉽게 찾을 수 있다. 이렇게 변환하려면 변경순번 값이 고정너비로 입력돼 있어야 한다. 애초에 변경순번 데이터타입을 숫자형으로 설계했다면 이렇게 튜닝할 일이 없을 것이다.
```
SELECT NVL(TO_NUMBER(MAX(변경순번)), 0)
FROM   상태변경이력
WHERE  장비번호 = 'C'
AND    변경일자 = '20180316'
```

- 또다른 아래의 SQL은 장비구분코드 = 'A001'에 해당하는 장비들의 최종 변경일자를 스칼라 서브쿼리를 이용해 상태변경이력 테이블에서 조회하고 있다. 정렬 연산 없이 MIN/MAX, FIRST ROW 방식으로 실행하고 있음을 실행계획에서 확인할 수 있다.
```
SELECT 장비번호, 장비명, 상태코드
       , (SELECT MAX(변경일자)
          FROM   상태변경이력
          WHERE  장비번호 = P.장비번호) 최종변경일자
FROM   장비 P
WHERE  장비구분코드 = 'A001'
```

- 최종 변경일자에 더해 최종 변경순번까지 출력하려면 SQL을 어떻게 작성해야 할까? 아래와 같이 작성할 수 있지만, 상태변경이력 테이블을 여러 번 읽어야 하므로 비효율적이다.
- PK 컬럼이 더 많아지면 SQL문도 훨씬 더 복잡해지므로 성능도 나빠진다.
```
SELECT 장비번호, 장비명, 상태코드
       , (SELECT MAX(변경일자)
          FROM   상태변경이력
          WHERE  장비번호 = P.장비번호) 최종변경일자
       , (SELECT MAX(변경순번)
          FROM   상태변경이력
          WHERE  장비번호 = P.장비번호
          AND    변경일자 = (SELECT MAX(변경일자)
                            FROM   상태변경이력
                            WHERE   장비번호 = P.장비번호)) 최종변경순번
FROM   장비 P
WHERE  장비구분코드 = 'A001'
```

- 아래와 같이 작성하면 PK 컬럼이 많아져도 덜 복잡하다.
- 하지만 각 장비당 이력이 많지 않으면 크게 상관없지만, 이력이 많다면 성능에 문제가 될 수 있는 패턴이다. 인덱스 컬럼을 가공했기 때문이다.
```
SELECT 장비번호, 장비명, 상태코드
       , SUBSTR(최종이력, 1, 8) 최종변경일자
       , SUBSTR(최종이력, 9)    최종변경순번
FROM (
      SELECT 장비번호, 장비명, 상태코드
             , (SELECT MAX(변경일자 || 변경순번)
                FROM   상태변경이력
                WHERE  장비번호 = P.장비번호) 최종이력
      FROM 장비 P
      WHERE 장비구분코드 = 'A001'               
)
```

- 각 장비에 속한 과거 이력 데이터를 모두 읽어야 하므로 장비당 이력 레코드가 많다면 상태변경이력 테이블을 여러 번 읽는 복잡한 SQL보다 성능이 더 안 좋을 수 있다.
- 아래는 장비당 이력 레코드가 많은 상태에서 수집한 트레이스 결과다. 상태변경이력_PK 인덱스에서 1,825,000개 레코드를 읽으면서 6,830개 블록을 읽었다. 메인쿼리 장비 테이블에서는 읽은 데이터가 10건 밖에 안된다.
```
ROWS    ROW SOURCE OPERATION
------  ------------------------------------------------------------
     10 SORT AGGREGATE (cr=6830 pr=6488 pw=0 time=0 us)
1825000  INDEX RANGE SCAN 상태변경이력_PK (cr=6830 pr=6488 pw=0 ...)
     10 TABLE ACCESS BY INDEX ROWID 장비 (cr=4 pr=16 pw=0 time=0 us)
     10  INDEX RANGE SCAN 장비_N1 (cr=2 pr=8 pw=0 time=90 us)
```

- 이에 대한 해법을 공부하려면 Top N 알고리즘을 먼저 알아야 한다. (5.3.4 이력 조회에서 계속)

### 2.2.7 자동 형변환
```
SELECT * FROM 고객
WHERE 생년월일 = 19821225
```
- 고객 테이블에 생년월일이 선두 컬럼인 인덱스가 있다고 하자. 위 SQL은 생년월일 컬럼을 조건절에서 가공하지 않았는데도 옵티마이저는 테이블 전체 스캔을 수행했다.
- 그 이유는 옵티마이저가 SQL을 아래와 같이 변환했기 때문이다.
```
SELECT * FROM 고객
WHERE TO_NUMBER(생년월일) = 19821225
```
- 이는 고객 테이블 생년월일 컬럼이 문자형인데 조건절 비교값을 숫자형으로 표현했기 때문에 나타난 현상이다. 각 조건절에서 양쪽 값의 데이터 타입이 서로 다르면 값을 비교할 수 없다.
- 타입 체크를 엄격히 함으로써 컴파일 시점에 에러를 내는 DBMS도 있고, 자동으로 형변환 처리해주는 DBMS도 있다. 오라클은 후자이다.

```
SELECT * FROM 고객
WHERE 가입일자 = '01-JAN-2018';
```
- 위 SQL과 같이 날짜형(가입일자)과 문자형('01-JAN-2018')이 만나면 날짜형이 이긴다. 이 경우에는 좌변 컬럼 기준으로 우변을 변환하므로 인덱스 사용에 문제가 없다.

```
SELECT * FROM 고객
WHERE 가입일자 = TO_DATE('01-JAN-2018', 'DD-MON-YYYY');
```
- NLS_DATE_FORMAT 파라미터가 다르게 설정된 환경에서 수행하면 컴파일 오류가 나거나 결과집합이 틀려질 수 있다. 위와 같이 날짜 포맷을 정확히 지정해 주는 습관이 필요하다.

```
SELECT * FROM 고객
WHERE 고객번호 LIKE '9410%'

Predicate information (identified by opration id):
1 - filter(TO_CHAR("고객번호") LIKE '9410%')
```
- 숫자형과 문자형이 만나면 숫자형이 이긴다고 했지만, 연산자가 LIKE일 때는 다르다. LIKE 자체가 문자열 비교 연산자이므로 이때는 문자열 기준으로 숫자형 컬럼이 변환된다.

```
-- SQL1 : 사용자가 계좌번호를 입력할 경우
SELECT * FROM 거래
WHERE 계좌번호 = :acnt_no
AND   거래일자 between :trd_dt1 and :trd_dt2

-- SQL2 : 사용자가 계좌번호를 입력하지 않을 경우
SELECT * FROM 거래
WHERE 거래일자 between :trd_dt1 and :trd_dt2
```
- 위 SQL을 하나로 처리하기 위해 아래와 같이 LIKE 조건을 사용하는 경우가 있다.
```
SELECT * FROM 거래
WHERE 계좌번호 LIKE :acnt_no || '%'
AND   거래일자 between :trd_dt1 and :trd_dt2
```
- 이 방식을 사용하면 LIKE, BETWEEN 조건을 같이 사용했으므로 인덱스 스캔 효율이 안 좋아진다. 계좌번호 컬럼이 숫자형일 때 특히 주의가 필요하다. 숫자형 컬럼을 LIKE 조건으로 검색하면 자동 형변환이 발생해 계좌번호가 아예 인덱스 액세스 조건으로 사용되지 못하기 때문이다.
- 계좌번호가 형변환되면 `계좌번호 + 거래일자` 순으로 구성된 인덱스를 Range Scan 할 수 없다. `거래일자 + 계좌번호` 순으로 구성된 인덱스는 Range Scan 할 수 있지만, 인덱스 스캔 효율은 매우 안 좋아진다. 왜냐하면 거래일자 조회 범위에 속한 거래 데이터를 모두 읽으면서 계좌번호를 필터링하기 때문이다.

#### 자동 형변환 주의
```
where n_col = v_col
              *
2행에 오류:
ORA-01722: 수치가 부적합합니다
```
- 위와 같이 숫자형 컬럼(n_col)에 문자형 컬럼(v_col)을 비교하면 문자형 컬럼이 숫자형으로 변환되는데, 만약 문자형 컬럼에 숫자로 변환할 수 없는 문자열이 입력되면 쿼리 수행 도중 에러가 발생한다.

```
SELECT ROUND(AVG(SAL)) AVG_SAL
, MIN(SAL) MIN_SAL
, MAX(SAL) MAX_SAL
, MAX(DECODE(JOB, 'PRESIDENT', NULL, SAL)) MAX_SAL2
FROM EMP2;

AVG_SAL MIN_SAL MAX_SAL MAX_SAL2
------- ------- ------- --------
2073    800     5000    950
```
- 실행 에러가 아니라 결과 오류가 생기는 사례도 있다. 위와 같이 EMP 테이블에서 직원들 급여 수준을 조회해 보았다.
- 가장 적게 받는 직원 급여가 800이고, 가장 많이 받는 직원 급여는 5,000이다. 가장 많이 받는 직원은 당연히 'PRESIDENT'일 것으로 예상되므로 이를 제외하고 가장 많이 받는 직원의 급여(MAX_SAL2)도 함께 조회했다. 그런데 그 값이 평균 급여인 2,073에도 못 미치는 950으로 나타났다.

```
SELECT EMPNO, ENAME, JOB, SAL
FROM   JOB
WHERE  JOB <> 'PRESIDENT'
ORDER BY SAL DESC ;

EMPNO ENAME JOB     SAL
----- ----- ------- ----
7902  FORD  ANALYST 3000
7788  SCOTT ANALYST 3000
7566  JONES MANAGER 2975
...   ...   ...
```
- 레코드 단위로 조회해 보니 'PRESIDENT'를 제외한 두 명의 'ANALYST' 급여가 3,000으로 가장 높았다.
- 앞의 집계 쿼리에서 엉뚱한 값이 나온 이유는 오라클이 DECODE 함수를 처리할 때 내부에서 사용하는 자동 형변환 규칙 때문이다.
- DECODE(A, B, C, D)를 처리할 때 'A = B'이면 C를 반환하고, 아니면 D를 반환한다. 이때 반환값의 데이터 타입은 세 번째 인자 C에 의해 결정된다. 따라서 C가 문자형이고 D가 숫자형이면, D는 문자형으로 변환된다.
- DECODE 함수가 가진 또 하나의 내부 규칙은 세 번째 인자(C)가 NULL 값이면 VARCHAR2로 취급한다는 사실이다.
- 앞의 집계 쿼리에서 세 번째 인자가 NULL 값이므로 네 번째 인자 SAL을 문자열로 변환하고, 문자열 기준으로 가장 큰 값(950)을 출력한 것이다. 아래와 같이 데이터 타입을 명시적으로 일치시켜 주면 위와 같은 오류를 피할 수 있다.
- TO_NUMBER(NULL) 대신 0을 써도 된다.
```
SELECT ROUND(AVG(SAL)) AVG_SAL
, MIN(SAL) MIN_SAL
, MAX(SAL) MAX_SAL
, MAX(DECODE(JOB, 'PRESIDENT', TO_NUMBER(NULL), SAL)) MAX_SAL2
FROM EMP2;

AVG_SAL MIN_SAL MAX_SAL MAX_SAL2
------- ------- ------- --------
2073    800     5000    3000
```
- 자동 형변환에 대한 결론은 이 기능에 의존하지 말고, 인덱스 컬럼 기준으로 반대편 컬럼 또는 값을 정확히 형변환해 주어야 한다.


## 2.3 인덱스 확장기능 사용법


### 2.3.1 Index Range Scan
![Index Range Scan](https://github.com/user-attachments/assets/013b3807-b4bd-463e-8a09-5e5afb7ebfb1)
- Index Range Scan은 B*Tree 인덱스의 가장 일반적이고 정상적인 형태의 액세스 방식이다.
- 인덱스 루트에서 리프 블록까지 수직적으로 탐색한 후에 '필요한 범위(Range)만' 스캔한다.
- 인덱스를 Range Scan 하려면 선두 컬럼을 가공하지 않은 상태로 조건절에 사용해야 한다. 반대로, 선두 컬럼을 가공하지 않은 상태로 조건절에 사용하면 Index Range Scan은 무조건 가능하다.


### 2.3.2 Index Full Scan
![Index Full Scan](https://github.com/user-attachments/assets/e9004fb3-18e1-450e-afef-3ee93cf0a194)
- 수직적 탐색 없이 인덱스 리프 블록을 처음부터 끝까지 수평적으로 탐색하는 방식이다.
- Index Full Scan은 대개 데이터 검색을 위한 최적의 인덱스가 없을 때 차선으로 선택된다.
```
CREATE INDEX EMP_ENAME_SAL_IDX ON EMP (ENAME, SAL);

SET AUTOTRACE TRACEONLY EXP

SELECT * FROM EMP
WHERE SAL > 2000
ORDER BY ENAME ;
```
- 위 SQL에서 인덱스 선두 컬럼인 ENAME이 조건절에 없으므로 INDEX RANGE SCAN은 불가능하다. 뒤쪽에 SAL 컬럼이 인덱스에 있으므로 Index Full Scan을 통해 SAL이 2000보다 큰 레코드를 찾을 수 있다.

#### Index Full Scan의 효용성
- 위 SQL처럼 인덱스 선두 컬럼(ENAME)이 조건절에 없으면 옵티마이저는 먼저 Table Full Scan을 고려한다. 그런데 대용량 테이블이어서 Table Full Scan에 따른 부담이 크다면, 옵티마이저는 인덱스 활용을 다시 고려하지 않을 수 없다.
- 데이터 저장공간은 '컬럼 길이 x 레코드 수'에 의해 결정되므로 인덱스가 차지하는 면적은 테이블보다 훨씬 적다. 인덱스를 Range Scan 할 수 없을 때, 테이블 전체를 스캔하기보다 인덱스 전체를 스캔하면 어떨까? 만약 인덱스 스캔 단계에서 대부분 레코드를 필터링하고 아주 일부만 테이블을 액세스하는 상황이라면, 면적이 큰 테이블보다 인덱스를 스캔하는 쪽이 유리하다. 그럴 때 옵티마이저는 Index Full Scan 방식을 선택한다.

```
CREATE INDEX EMP_ENAME_SAL_IDX ON EMP (ENAME, SAL);

SELECT *
FROM   EMP
WHERE  SAL > 9000
ORDER BY ENAME ;
```
- SAL > 9000인 사원이 전체 중 극히 일부라면 Table Full Scan보다는 Index Full Scan을 통한 필터링이 효과적이다.
- 하지만 이 방식은 적절한 인덱스가 없어 Index Range Scan의 차선택으로 선택한 것이다. 수행빈도가 낮은 SQL이면 상관 없지만, 그렇지 않다면 SAL 컬럼이 선두인 인덱스를 생성해주는 것이 좋다.

#### 인덱스를 이용한 소트 연산 생략
- 인덱스를 Full Scan하면 Range Scan과 마찬가지로 결과집합이 인덱스 컬럼 순으로 정렬된다. 따라서 Sort Order By 연산을 생략할 목적으로 사용할 수도 있다. 이때는 차선책이 아니라 옵티마이저가 전략적으로 선택한 경우다.
```
SELECT /*+ FIRST_ROWS */ *
FROM   EMP
WHERE  SAL > 1000
ORDER BY ENAME ;
```
- SAL 조건절을 위와 같이 바꿔보자. 앞에서는 SAL > 9000인 사원을 찾았는데, 지금은 SAL > 1000인 사원을 찾고 있다.
- 대부분 사원이 SAL > 1000 조건을 만족하는 상황에서 Index Full Scan을 선택하면, 거의 모든 레코드에 대해 테이블 액세스가 발생하므로 Table Full Scan보다 오히려 불리하다. 만약 SAL이 인덱스 선두 컬럼이어서 Index Range Scan 하더라도 마찬가지다.
- 그럼에도 불구하고 옵티마이저가 인덱스를 선택한 이유는, 사용자가 FIRST_ROWS 힌트로 옵티마이저 모드를 바꿨기 때문이다. 소트 연산을 생략함으로써 전체 집합 중 처음 일부를 빠르게 출력할 목적으로 옵티마이저가 Index Full Scan 방식을 선택한 것이다. 이 선택은 부분범위 처리가 가능한 상황에서 극적인 성능 개선 효과가 있다.
- 주의할 점은, 사용자가 처음 의도(부분범위 처리 활용)와 달리 FETCH를 멈추지 않고 데이터를 끝까지 읽는다면 TABLE FULL SCAN보다 훨씬 더 많은 I/O를 일으키고 결과적으로 수행 속도도 훨씬 더 느려진다.


### 2.3.3 Index Unique Scan
![Index Unique Scan](https://github.com/user-attachments/assets/91172a34-989b-4fed-942b-1439e1ebcdac)
- 수직적 탐색만으로 데이터를 찾는 스캔 방식으로서, Unique 인덱스를 '=' 조건으로 탐색하는 경우에 작동한다.
- Unique 인덱스가 존재하는 컬럼은 중복 값이 입력되지 않게 DBMS가 데이터 정합성을 관리해 준다. 따라서 해당 인덱스 키 컬럼을 모두 '=' 조건으로 검색할 때는 데이터를 한 건 찾는 순간 더 이상 탐색할 필요가 없다.
- Unique 인덱스라고 해도 범위검색 조건(BETWEEN, 부등호, LIKE)으로 검색할 때는 Index Range Scan으로 처리된다. 예를들어, EMPNO >= 7788 조건으로 검색하면 수직적 탐색만으로는 조건에 해당하는 레코드를 모두 찾을 수 없기 때문이다.
- 또한, Unique 결합 인덱스에 일부 컬럼만으로 검색할 때도 Index Range Scan이 나타난다. 예를 들어, 주문상품 PK 인덱스를 `주문일자 + 고객ID + 상품ID`로 구성했는데, 주문일자와 고객ID로만 검색하는 경우를 말한다.


### 2.3.4 Index Skip Scan
- 인덱스 선두 컬럼을 조건절에 사용하지 않으면 옵티마이저는 기본적으로 Table Full Scan을 선택한다.
- Table Full Scan보다 I/O를 줄일 수 있거나 정렬된 결과를 쉽게 얻을 수 있다면, Index Full Scan을 사용하기도 한다.
- 오라클은 인덱스 선두 컬럼이 조건절에 없어도 인덱스를 활용하는 새로운 스캔 방식을 9i 버전에서 선보였는데, Index Skip Scan이 바로 그것이다.
- Index Skip Scan 방식은 조건절에 빠진 **인덱스 선두 컬럼의 Distinct Value 개수가 적고 후행 컬럼의 Distinct Value 개수가 많을 때 유용**하다. 예를 들어, 고객 테이블에서 Distinct Value 개수가 가장 적은 컬럼은 '성별'이다. 
Dinstinct Value 개수가 가장 많은 컬럼은 '고객번호'다.

![그림2-20](https://github.com/user-attachments/assets/6f3d29dd-b213-4243-8d12-1eca84b73425)

```
SELECT *
FROM   사원
WHERE  성별 = '남'
AND    연봉 BETWEEN 2000 AND 4000 ;
```
- 위 SQL에서 성별과 연봉 두 컬럼으로 구성된 결합 인덱스가 있을 때, 먼저 성별이 '남'이면서 연봉 >= 2000인 첫 번째 레코드를 찾아야 한다.
- 3번 리프 블록주소가 성별='남'과 연봉>=1500이고 4번 리프 블록주소가 성별='남'과 연봉>=5000일 경우, 3번 리프 블록에서 시작하여 성별='남'이면서 연봉>=2000인 첫 번째 레코드를 만난다면 거기서부터 리프 블록을 차례로 스캔한다. 스캔하다가 성별='남'이면서 연봉>4000인 첫 번째 레코드를 만나는 순간 스캔을 멈춘다.

```
SELECT /*+ INDEX_SS(사원 사원_IDX) */ *
FROM   사원
WHERE  연봉 BETWEEN 2000 AND 4000 ;
```
- 위 SQL문에서는 인덱스 선두 컬럼인 성별 조건을 뺐다.
- Index Skip Scan을 유도하거나 방지하고자 할 때, INDEX_SS, NO_INDEX_SS 힌트를 사용한다.
- Index Skip Scan은 루트 또는 브랜치 블록에서 읽은 컬럼 값 정보를 이용해 조건절에 부합하는 레코드를 포함할 '가능성이 있는' 리프 블록만 골라서 액세스하는 스캔 방식이다.

![Index Skip Scan](https://github.com/user-attachments/assets/3c715dd3-1466-4d50-a426-4683fb1a5793)
- 그림2-20 인덱스 루트 블록에서 첫 번째 레코드가 가리키는 리프 블록은 `남 & 800` 이하인 레코드를 담고 있다. 이 블록은 액세스하지 않아도 괜찮다. 하지만 '남'보다 작은 성별값이 혹시 존재한다면, 그 사원에 대한 인덱스 레코드는 모두 1번 리프 블록에 저장되므로 액세스해야만 한다. 개발자는 성별에 '남'과 '여' 두 개 값만 존재한다는 사실을 알지만 옵티마이저는 모른다.
- 두 번째 레코드가 가리키는 리프 블록은 `남 & 800` 이상이면서 `남 & 1500` 이하인 레코드를 담고 있다. `2000 <= 연봉 <= 4000`인 값이 존재할 가능성이 없으므로 이 블록은 액세스 하지 않고 Skip한다.
- 세 번째 레코드가 가리키는 리프 블록은 `남 & 1500` 이상이면서 `남 & 5000` 이하인 레코드를 담고 있으므로 액세스한다.
- 네 번째 레코드가 가리키는 리프 블록은 `남 & 5000` 이상이면서 `남 & 8000` 이하인 레코드를 담고 있으므로 Skip한다.
- 다섯 번째 레코드가 가리키는 리프 블록도 네 번째 레코드와 마찬가지 이유로 Skip한다.
- 여섯 번째 레코드가 가리키는 리프 블록은 `남 & 10000` 이상이므로 `2000 <= 연봉 <= 4000` 구간을 초과한다. 따라서 액세스하지 않아도 될 것 같지만 액세스해야 한다. 여자 중에서 `연봉 < 3000`이거나 '남'과 '여' 사이에 다른 성별이 혹시 존재한다면 이 리프 블록에 저장되고, 연봉 = 3000인여자 직원도 뒤쪽에 일부 저장돼 있을 수 있기 때문이다.
- 일곱 번째 레코드가 가리키는 리프 블록은 액세스하고, 여덟 번째와 아홉 번째 레코드가 가리키는 리프 블록은 Skip 해도 된다.
- 마지막 열 번째 리프 블록은 `여 & 10000` 이상이므로 `2000 <= 연봉 <= 4000` 구간을 초과하지만 '여'보다 값이 큰 미지의 성별 값이 존재한다면 여기에 모두 저장될 것이므로 액세스해야만 한다.

#### Index Skip Scan이 작동하지 위한 조건
- Index Skip Scan은 Distinct Value 개수가 적은 선두 컬럼이 조건절에 없고 후행컬럼의 Distinct Value 개수가 많을 때 효과적이다. 하지만 인덱스 선두 컬럼이 없을 때만 Index Skip Scan이 작동하는 것은 아니다.

```
일별업종별거래_PK : 업종유형코드 + 업종코드 + 기준일자
```
```
SELECT /*+ INDEX_SS(A 일별업종별거래_PK) */
       기준일자, 업종코드, 체결건수, 체결수량, 거래대금
FROM   일별업종별거래 A
WHERE  업종유형코드 = '01'
AND    기준일자 BETWEEN '20080501' AND '20080531'
```
- 위 SQL처럼 선두 컬럼(업종유형코드)에 대한 조건절은 있고 중간 컬럼(업종코드)에 대한 조건절이 없는 경우에도 Skip Scan을 사용할 수 있다.
- 만약 위 SQL에 Index Range Scan을 사용한다면, 업종유형코드 = '01'인 인덱스 구간을 '모두' 스캔해야한다.
- Index Skip Scan을 사용한다면, 업종유형코드 = '01'인 구간에서 기준일자가 '20080501'보다 크거나 같고 '20080531'보다 작거나 같은 레코드를 '포함할 가능성이 있는 리프 블록만' 골라서 액세스할 수 있다.

```
SELECT /*+ INDEX_SS(A 일별업종별거래_PK) */
       기준일자, 업종코드, 체결건수, 체결수량, 거래대금
FROM   일별업종별거래 A
WHERE  기준일자 BETWEEN '20080501' AND '20080531'
```
- 위 SQL과 같이 Distinct Value가 적은 두 개의 선두컬럼이 모두 조건절에 없는 경우에도 유용하게 사용할 수 있다.

```
일별업종별거래_X01 : 기준일자 + 업종유형코드
```
```
SELECT /*+ INDEX_SS(A 일별업종별거래_X01) */
       기준일자, 업종코드, 체결건수, 체결수량, 거래대금
FROM   일별업종별거래 A
WHERE  기준일자 BETWEEN '20080501' AND '20080531'
AND    업종유형코드 = '01'
```
- 선두컬럼이 부등호, BETWEEN, LIKE 같은 범위조건 검색일 때도 Index Skip Scan을 사용할 수 있다. 2008년 5월 1일부터 2008년 5월 31일 구간에서 업종유형코드가 '01'인 레코드만 선택하고자 하는 위 SQL이 있다.
- 만약 위 SQL에 Index Range Scan을 사용한다면, 기준일자 BETWEEN 조건을 만족하는 인덱스 구간을 '모두' 스캔해야 한다.
- Index Skip Scan을 사용한다면, 기준일자 BETWEEN 조건을 만족하는 인덱스 구간에서 업종유형코드 = '01'인 레코드를 '포함할 가능성이 있는 리프 블록만' 골라서 액세스할 수 있다.
- 인덱스는 기본적으로 최적의 Index Range Scan을 목표로 설계해야 하며, 수행 횟수가 적은 SQL을 위해 인덱스를 추가하는 것이 비효율적일 때 Index Skip Scan이나 Index Full Scan 방식을 차선책으로 활용하는 전략이 바람직하다.


### 2.3.5 Index Fast Full Scan
- Index Fast Full Scan은 Index Full Scan보다 빠르다. 이유는, 논리적인 인덱스 트리 구조를 무시하고 인덱스 세그먼트 전체를 Multiblock I/O 방식으로 스캔하기 때문이다. 관련 힌트는 `INDEX_FFS`와 `NO_INDEX_FFS`이다.

![그림2-22](https://github.com/user-attachments/assets/9e0fc670-75e5-4ac4-8bc1-ae63821998df)
- 위 그림에서 화살표는 인덱스의 논리적인 연결 구조를 표시한 것이다. 리프 블록 간에 실제로는 양방향 연결 리스트(Double Linked List) 구조를 갖지만, 단순하게 표현하려고 1번부터 8번까지 단방향 연결 리스트 구조로 표시하였다.

![그림2-23](https://github.com/user-attachments/assets/27027a2d-cade-4544-9af9-acab25a70fdc)
- 앞의 그림에서는 논리적 순서로 블록들을 배치했다면, 위 그림에서는 물리적 순서에 따라 재배치했다. 물리적 순서로 배치했지만 논리적 순서를 화살표로 표시하였다.
- Index Full Scan은 인덱스의 논리적 구조에 따라 루트 -> 브랜치1 -> 1 -> 2 -> 3 -> 4 -> 5 -> 6 -> 7 -> 8번 순서로 블록을 읽어들인다.
- 반면, Index Fast Full Scan은 물리적으로 디스크에 저장된 순서대로 인덱스 리프 블록들을 읽어들인다. Multiblock I/O 방식으로 위 그림의 왼쪽 익스텐트에서 1 -> 2 -> 8 -> 3번 순으로 읽고, 그 다음 오른쪽 익스텐트에서 7 -> 4 -> 5 -> 6번 순으로 읽는다. 루트와 두 개의 브랜치 블록도 읽지만 필요 없는 블록이므로 버린다.

<br/>

- Index Fast Full Scan은 Multiblock I/O 방식을 사용하므로 디스크로부터 대량의 인덱스 블록을 읽어야 할 때 큰 효과를 발휘한다. 속도는 빠르지만, 인덱스 리프 노드가 갖는 연결 리스트 구조를 무시한 채 데이터를 읽기 때문에 결과집합이 인덱스 키 순서대로 정렬되지 않는다. 쿼리에 사용한 컬럼이 모두 인덱스에 포함돼 있을 때만 사용할 수 있다는 점도 기억할 필요가 있다.
- Index Range Scan 또는 Index Full Scan과 달리, 인덱스 파티션 돼 있지 않더라도 병렬 쿼리가 가능한 것도 중요한 특징 중 하나다. 병렬 쿼리 시에는 Direct Path I/O 방식을 사용하기 때문에 I/O 속도가 더 빨라진다.
- Index Full Scan과 Index Fast Full Scan의 특징을 요약하면 아래와 같다.

![표3-4](https://github.com/user-attachments/assets/17957844-ec35-4be3-9f35-1f8945a9aa37)


### 2.3.6 Index Range Scan Descending
![그림2-24](https://github.com/user-attachments/assets/e21cd91c-5b01-48c1-ba17-c2bf78e342c5)
- Index Range Scan과 기본적으로 동일한 스캔 방식이다. 위 그림처럼 인덱스를 뒤에서 앞쪽으로 스캔하기 때문에 내림차순으로 정렬된 결과집합을 얻는다는 점만 다르다.

```
SELECT * FROM EMP
WHERE  EMPNO > 0
ORDER BY EMPNO DESC

Execution Plan
----------------------------------------------------------------
0   SELECT STATEMENT Optimizer=ALL_ROWS
1 0  TABLE ACCESS (BY INDEX ROWID) OF 'EMP' (TABLE)
2 1   INDEX (RANGE SCAN DESCENDING) OF 'PK_EMP' (INDEX (UNIQUE))
```
- 위 SQL처럼 EMP 테이블을 EMPNO 기준으로 내림차순 정렬하고자 할 때 EMPNO 컬럼에 인덱스가 있으면 옵티마이저가 알아서 인덱스를 거꾸로 읽는 실행계획을 수립한다.
- 만약 옵티마이저가 인덱스를 거꾸로 읽지 않는다면, INDEX_DESC 힌트를 이용해 유도할수있다.

```
CREATE INDEX EMP_X02 ON EMP(DEPTNO, SAL) ;

SELECT DEPTNO, DNAME, LOC
     , (SELECT MAX(SAL) FROM EMP WHERE DEPTNO = D.DEPTNO)
FROM DEPT D

Execution Plan
----------------------------------------------------------------
0   SELECT STATEMENT Optimizer=ALL_ROWS
1 0  SORT (AGGREGATE)
2 1   FIRST ROW
3 2    INDEX (RANGE SCAN (MIN/MAX)) OF 'EMP_X02' (INDEX)
4 0  TABLE ACCESS (FULL) OF 'DEPT' (TABLE)
```
- 위 SQL처럼 MAX 값을 구하고자 할 때도 해당 컬럼에 인덱스가 있으면 인덱스를 뒤에서부터 한 건만 읽고 멈추는 실행계획이 잦동으로 수립된다.