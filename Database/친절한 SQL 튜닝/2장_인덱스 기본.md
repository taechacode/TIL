# 2장 인덱스 기본

## 2.1 인덱스 구조 및 탐색

### 2.1.1 미리 보는 인덱스 튜닝

#### 인덱스 튜닝의 두 가지 핵심요소
- 인덱스는 큰 테이블에서 소량 데이터를 검색할 때 사용한다. (온라인 트랜잭션 처리 Online Transaction Processing, OLTP 등)
- 세부적인 인덱스 튜닝 방법으로 여러 가지가 있지만, 크게 두 가지로 나뉜다.
    - 인덱스 스캔 효율화 튜닝
        - 인덱스 스캔 과정에서 발생하는 비효율을 줄인다.
        - 학생명부에서 시력이 1.0~1.5인 홍길동 학생을 찾는 경우, 학생명부를 이름과 시력순으로 정렬해 두었다면, 소량만 스캔하면 된다.
        - 하지만 학생명부를 시력과 이름순으로 정렬해 두었다면, 똑같이 두 명을 찾는데도 많은 양을 스캔해야 한다.
    - 랜덤 액세스 최소화 튜닝
        - 테이블 액세스 횟수를 줄인다.
        - 학생명부에서 시력이 1.0~1.5인 홍길동 학생을 찾는 경우를 생각해본다. 시력이 1.0~1.5인 학생은 50명이고, 이름이 홍길동인 학생은 5명이다.
        - 만약 이름만으로 정렬한 학생명부와 시력만으로 정렬한 학생명부가 따로 하나씩 있다면 이름순으로 정렬한 학생명부가 효율적이다.

#### SQL 튜닝은 랜덤 I/O와의 전쟁
- 데이터베이스 성능이 느린이유는 디스크 I/O 때문이다. 읽어야 할 데이터량이많고, 그 과정에 디스크 I/O가 많이 발생할 때 느리다. 인덱스를 많이 사용하는 OLTP 시스템이라면 디스크 I/O 중에서도 랜덤 I/O가 특히 중요하다.

### 2.1.2 인덱스 구조
- 데이터베이스에서 인덱스 없이 데이터를 검색하려면, 테이블을 처음부터 끝까지 모두 읽어야 한다. 반면, 인덱스를 이용하면 일부만 읽고 멈출 수 있다. 즉, 범위 스캔(Range Scan)이 가능하다. 범위 스캔이 가능한 이유는 인덱스가 정렬돼 있기 때문이다.
- DBMS는 일반적으로 B*Tree를 사용한다.
- 루트와 브랜치블록에는 키값을 갖지 않는 특별한 레코드가 하나있다. 가장 왼쪽 첫 번째 레코드다. 이를 `LMC`라고 하며, `Leftmost Child`의 줄임말이다. LMC는 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킨다.
- 리프 블록에 저장된 각 레코드는 키값 순으로 정렬돼 있을 뿐만 아니라 테이블 레코드를 가리키는 주소값, 즉 `ROWID`를 갖는다. 인덱스 키값이 같으면 ROWID 순으로 정렬된다.
- 인덱스를 스캔하는 이유는, 검색 조건을 만족하는 소량의 데이터를 빨리 찾고 거기서 ROWID를 얻기 위해서다.
    - ROWID = 데이터 블록 주소 + 로우 번호(블록 내 순번)
    - 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호(데이터파일 내에서 부여한 상대적 순번)
- 인덱스 탐색 과정은 수직적 탐색과 수평적 탐색으로 나눌 수 있다.
    - 수직적 탐색 : 인덱스 스캔 시작지점을 찾는 과정
    - 수평적 탐색 : 데이터를 찾는 과정

### 2.1.3 인덱스 수직적 탐색

### 2.1.4 인덱스 수평적 탐색

### 2.1.5 결합 인덱스 구조와 탐색
- 두 개 이상 컬럼을 결합해서 인덱스를 만들 수도 있다. (결합 인덱스 탐색 과정은 책 79P 참고)
- 인덱스를 [고객명 + 성별]로 구성하든, [성별 + 고객명]으로 구성하든 읽는 인덱스 블록 개수가 똑같다.
- **인덱스 선두 컬럼을 모두 "=" 조건으로 검색할 때**는 어느 컬럼을 인덱스 앞쪽에 두든 블록 I/O 개수가 같으므로 성능도 똑같다.

## 2.2 인덱스 기본사용법

## 2.3 인덱스 확장기능 사용법