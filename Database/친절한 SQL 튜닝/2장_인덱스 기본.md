# 2장 인덱스 기본

## 2.1 인덱스 구조 및 탐색

### 2.1.1 미리 보는 인덱스 튜닝

#### 인덱스 튜닝의 두 가지 핵심요소
- 인덱스는 큰 테이블에서 소량 데이터를 검색할 때 사용한다. (온라인 트랜잭션 처리 Online Transaction Processing, OLTP 등)
- 세부적인 인덱스 튜닝 방법으로 여러 가지가 있지만, 크게 두 가지로 나뉜다.
    - 인덱스 스캔 효율화 튜닝
        - 인덱스 스캔 과정에서 발생하는 비효율을 줄인다.
        - 학생명부에서 시력이 1.0~1.5인 홍길동 학생을 찾는 경우, 학생명부를 이름과 시력순으로 정렬해 두었다면, 소량만 스캔하면 된다.
        - 하지만 학생명부를 시력과 이름순으로 정렬해 두었다면, 똑같이 두 명을 찾는데도 많은 양을 스캔해야 한다.
    - 랜덤 액세스 최소화 튜닝
        - 테이블 액세스 횟수를 줄인다.
        - 학생명부에서 시력이 1.0~1.5인 홍길동 학생을 찾는 경우를 생각해본다. 시력이 1.0~1.5인 학생은 50명이고, 이름이 홍길동인 학생은 5명이다.
        - 만약 이름만으로 정렬한 학생명부와 시력만으로 정렬한 학생명부가 따로 하나씩 있다면 이름순으로 정렬한 학생명부가 효율적이다.

#### SQL 튜닝은 랜덤 I/O와의 전쟁
- 데이터베이스 성능이 느린이유는 디스크 I/O 때문이다. 읽어야 할 데이터량이많고, 그 과정에 디스크 I/O가 많이 발생할 때 느리다. 인덱스를 많이 사용하는 OLTP 시스템이라면 디스크 I/O 중에서도 랜덤 I/O가 특히 중요하다.

### 2.1.2 인덱스 구조
- 데이터베이스에서 인덱스 없이 데이터를 검색하려면, 테이블을 처음부터 끝까지 모두 읽어야 한다. 반면, 인덱스를 이용하면 일부만 읽고 멈출 수 있다. 즉, 범위 스캔(Range Scan)이 가능하다. 범위 스캔이 가능한 이유는 인덱스가 정렬돼 있기 때문이다.
- DBMS는 일반적으로 B*Tree를 사용한다.
- 루트와 브랜치블록에는 키값을 갖지 않는 특별한 레코드가 하나있다. 가장 왼쪽 첫 번째 레코드다. 이를 `LMC`라고 하며, `Leftmost Child`의 줄임말이다. LMC는 자식 노드 중 가장 왼쪽 끝에 위치한 블록을 가리킨다.
- 리프 블록에 저장된 각 레코드는 키값 순으로 정렬돼 있을 뿐만 아니라 테이블 레코드를 가리키는 주소값, 즉 `ROWID`를 갖는다. 인덱스 키값이 같으면 ROWID 순으로 정렬된다.
- 인덱스를 스캔하는 이유는, 검색 조건을 만족하는 소량의 데이터를 빨리 찾고 거기서 ROWID를 얻기 위해서다.
    - ROWID = 데이터 블록 주소 + 로우 번호(블록 내 순번)
    - 데이터 블록 주소 = 데이터 파일 번호 + 블록 번호(데이터파일 내에서 부여한 상대적 순번)
- 인덱스 탐색 과정은 수직적 탐색과 수평적 탐색으로 나눌 수 있다.
    - 수직적 탐색 : 인덱스 스캔 시작지점을 찾는 과정
    - 수평적 탐색 : 데이터를 찾는 과정

### 2.1.3 인덱스 수직적 탐색
- 정렬된 인덱스 레코드 중 조건을 만족하는 첫 번째 레코드를 찾는 과정이다. 즉, **인덱스 스캔 시작지점을 찾는 과정**이다.
- 인덱스 수직적 탐색은 루트(Root) 블록에서부터 시작한다. 루트를 포함해 브랜치(Branch) 블록에 저장된 각 인덱스 레코드는 하위 블록에 대한 주소값을 갖는다. 루트에서 시작해 리프(Leaf) 블록까지 수직적 탐색이 가능한 이유다.
- 인덱스를 수직적으로 탐색할 때, 루트를 포함한 브랜치 블록은 등산 푯말과 같은 역할을 한다. '조건을 만족하는 첫 번째 레코드'가 목표지점이다. 푯말이 알려주는 대로 따라가다 보면 '조건을 만족하는 첫 번째 레코드'를 만날 수 있다.

### 2.1.4 인덱스 수평적 탐색
- 수직적 탐색을 통해 스캔 시작점을 찾았으면, 찾고자 하는데이터가 더 안 나타낼 때까지 인덱스 리프 블록을 수평적으로 스캔한다. 인덱스에서 본격적으로 **데이터를 찾는 과정**이다.
- 인덱스 리프 블록끼리는 서로 앞뒤 블록에 대한 주소값을 갖는다. 즉, 양방향 연결 리스트(double linked list) 구조다.
- 인덱스를 수평적으로 탐색하는 이유는 첫째, 조건절을 만족하는 데이터를 모두 찾기 위해서고 둘째, ROWID를 얻기 위해서다. 필요한 컬럼을 인덱스가 모두 갖고 있어 인덱스만 스캔하고 끝나는 경우도 있지만, 일반적으로 인덱스를 스캔하고서 테이블도 액세스한다. 이때 ROWID가 필요하다.

### 2.1.5 결합 인덱스 구조와 탐색
- 두 개 이상 컬럼을 결합해서 인덱스를 만들 수도 있다. (결합 인덱스 탐색 과정은 책 79P 참고)
- 인덱스를 [고객명 + 성별]로 구성하든, [성별 + 고객명]으로 구성하든 읽는 인덱스 블록 개수가 똑같다.
- **인덱스 선두 컬럼을 모두 "=" 조건으로 검색할 때**는 어느 컬럼을 인덱스 앞쪽에 두든 블록 I/O 개수가 같으므로 성능도 똑같다.

## 2.2 인덱스 기본사용법
### 2.2.1 인덱스를 사용한다는 것
- 인덱스 컬럼(정확히 말하면, 선두 컬럼)을 가공하지 않아야 인덱스를 정상적으로 사용할 수 있다.
- '인덱스를 정상적으로 사용한다'는 표현은 리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미한다. 즉 리프 블록 일부만 스캔하는 `Index Range Scan`을 의미한다.
- 인덱스 컬럼을 가공해도 인덱스를 사용할 수는 있지만, 스캔 시작점을 찾을 수 없고 멈출 수도 없어 리프 블록 전체를 스캔해야만 한다. 즉, 일부가 아닌 전체를 스캔하는 `Index Full Scan` 방식으로 동작한다.

### 2.2.2 인덱스를 Range Scan 할 수 없는 이유
```
"인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용(Range Scan)할 수 없다."
```
- 인덱스 컬럼을 가공했을 때 인덱스를 정상적으로 사용할 수 없는 이유는 **인덱스 스캔 시작점을 찾을 수 없기 때문**이다. Index Range Scan은 인덱스에서 일정 범위를 스캔한다는 뜻인데, 일정 범위를 스캔한다면 '시작점'과 '끝지점'이 있어야 한다.
- 예를 들어, 어느 초등학교에서 1학년부터 6학년까지 전교생을 생년월일 순으로 학교 운동장에 줄 세웠다. 여기서 2007년 1월에 태어난 학생을 찾으려면, 우선 2007년 1월 1일 이후에 태어난 첫 번째 학생을 찾고, 거기서부터 순서대로 스캔하다가 2007년 2월 1일 이후에 태어난 첫 번째 학생을 만나는 순간 멈추면 된다. 분명한 시작점과 끝지점이 있다.
- 아래의 조건절을 처리할 때도 시작점과 끝지점이 분명하다.
```
where 생년월일 between '20070101` and '20070131'
```

- 이번에는 년도와 상관없이 5월에 태어난 학생을 찾아보자. 스캔 시작지점과 종료지점을 알 수 없다. 전교생을 다 스캔해야만 한다.
- 아래의 조건절을 처리할 때도 같은 문제에 직면한다.
```
where substr(생년월일, 5, 2) = '05'
```
- 아래의 조건절도 마찬가지다. 가공하지 않은 주문수량으로 인덱스를 만들었는데, '값이 NULL이면 0으로 치환한 값' 기준으로 100보다 작은 레코드를 찾아달라고 쿼리를 작성하면 인덱스 스캔 시작지점을 찾을수가 없다.
```
where nvl(주문수량, 0) < 100
```

- 아래와 같이 LIKE로 중간 값을 검색할 때도 마찬가지다. '대한'으로 시작하는 값은 특정 구간에 모여 있으므로 Range Scan이 가능하지만, '대한'을 포함하는 값은 전체 구간에 걸쳐 흩어져 있어 Range Scan이 불가능하다.
```
where 업체명 like '%대한%'
```

- 아래와 같이 OR 조건으로 검색할 때, 수직적 탐색을 통해 전화번호가 '01012345678'이거나 고객명이 '홍길동'인 어느 한 시작지점을 바로 찾을 수 없다. 따라서 인덱스를 어떤 방식으로 수행해도 Range Scan 할 수 없다.
```
where (전화번호 = :tel_no OR 고객명 = :cust_nm)
```

- 아래와 같은 IN 조건절도 OR 조건을 표현하는 다른 방식일 뿐이다.
```
where 전화번호 in (:tel_no1, :tel_no2)
```

- 하지만 아래와 같이 SQL을 UNION ALL 방식으로 작성하면 각 브랜치 별로 인덱스 스캔 시작점을 찾을 수 있어 Range Scan이 가능하다.
```
select *
from 고객
where 전화번호 = :tel_no1
union all
select *
from 고객
where 전화번호 = "tel_no2
```

- 그래서 IN 조건절에 대해서는 SQL 옵티마이저가 IN-List Iterator 방식을 사용한다. IN-List 개수만큼 Index Range Scan을 반복하는 것이다. 이를 통해 SQL을 UNION ALL 방식으로 변환한 것과 같은 효과를 얻을 수 있다.
- 정리하면, **인덱스를 정상적으로 사용한다**는 표현은 리프 블록에서 스캔 시작점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것을 의미한다. 아래와 같은 조건절에는 인덱스를 정상적으로 사용할 수 없다. 기본적으로 Index Range Scan이 불가능하다. 단, OR 또는 IN 조건절은 옵티마이저의 쿼리변환 기능을 통해 Index Range Scan으로 처리되기도 한다.
```
where substr(생년월일, 5, 2) = '05'
where nvl(주문수량, 0) < 100
where 업체명 like '%대한%'
where (전화번호 = :tel_no1 or 고객명 = :cust_nm)
where 전화번호 in (:tel_no1, :tel_no2)
```

### 2.2.3 더 중요한 인덱스 사용 조건
- 인덱스를 `소속팀 + 사원명 + 연령` 순으로 구성해보자. **데이터를 소속팀 순으로 정렬하고, 소속팀이 같으면 사원명 순으로 정렬하고, 사원명까지 같으면 연령 순으로 정렬한다**는 의미다. 그렇다면 이름이 같은 사원이라도 소속팀이 다르면 서로 멀리 떨어지게 된다.
- 인덱스를 Range Scan 하기 위한 가장 첫 번째 조건은 인덱스 선두 컬럼이 가공하지 않은 상태로 조건절에 있어야 한다.
```
TXA1234_IX02 인덱스 : 기준연도 + 과세구분코드 + 보고회차 + 실명확인번호

select * from TXA1234
where 기준년도 = :stdr_year
and substr(과세구분코드, 1, 4) = :txtn_dcd
and 보고회사 = :rpt_tmrd
and 실명확인번호 = :rnm_cnfm_no
```
- 위 SQL은 인덱스 컬럼을 가공했는데, 어떻게 인덱스를 Range Scan 할 수 있는가?
- 인덱스 선두 컬럼인 `기준연도`를 조건절에서 가공하지 않았으므로 인덱스 Range Scan이 가능하다.
- 인덱스 선두 컬럼이 가공되지 않은 상태로 조건절에 있으면 인덱스 Range Scan은 무조건 가능하다.

#### 인덱스 컬럼 가공 예시
```
(튜닝 전)
select * from 업체
where substr(업체명, 1, 2) = '대한';

(튜닝 후)
select * from 업체
where 업체명 like '대한%';
```
```
(튜닝 전)
select * from 사원
where 월급여 * 12 = 36000000;

(튜닝 후)
select * from 사원
where 월급여 = 36000000 / 12;
```
```
(튜닝 전)
select * from 주문
where to_char(일시, 'yyyymmdd') = :dt;

(튜닝 후)
select * from 주문
where 일시 >= to_date(:dt, 'yyyymmdd') and 일시 < to_date(:dt, 'yyyymmdd') + 1;
```
```
(튜닝 전)
select * from 고객
where 연령 || 직업 = '30공무원';

(튜닝 후)
select * from 고객
where 연령 = 30 and 직업 = '공무원';
```
```
(튜닝 전)
select * from 회원사지점
where 회원번호 || 지점번호 = :str;

(튜닝 후)
select * from 회원사지점
where 회원번호 = substr(:str, 1, 2) and 지점번호 = substr(:str, 3, 4);
```
```
(튜닝 전)
select * from 주문
where nvl(주문수량, 0) >= 100;

* nvl 때문에 인덱스를 활용하지 않음.

(튜닝 후)
select * from 주문
where 주문수량 >= 100;
```
```
(튜닝 전)
select * from 주문
where nvl(주문수량, 0) < 100;

(튜닝 후)
* 주문수량이 NOT NULL이 아니면 수정.
함수기반 인덱스(FBI) 생성 고려 -> create index 주문_x01 on 주문(nvl(주문수량, 0));
```
- 인덱스를 Range Scan 한다고 해서 항상 성능이 좋은 건 아니다.

#### 인덱스 잘 타니까 튜닝 끝?
- 주문상품_N1 인덱스가 `주문일자 + 상품번호`순으로 구성됐고, 이 테이블에 쌓이는 데이터량은 하루 평균 100만건이라고 가정하자.
```
SELECT *
FROM 주문상품
WHERE 주문일자 = :ORD_DT
AND   상품번호 LIKE '%PING%' ;

SELECT *
FROM 주문상품
WHERE 주문일자 = :ORD_DT
AND   SUBSTR(상품번호, 1, 4) = 'PING' ;
```
- 위 조건절은 인덱스 선두 컬럼인 주문일자가 조건절에 있고, 가공하지 않은 상태이므로 인덱스를 Range Scan 하는 데 문제가 없다. 그런데 인덱스를 정말 잘 타는지는 인덱스 리프 블록에서 스캔하는 양을 따져봐야 알 수 있다.
- 위 SQL에서 상품번호는 스캔 범위를 줄이는 데 전혀 역할을 하지 못한다. 첫 번째 SQL은 중간 값 검색이기 때문이고, 두 번째 SQL은 컬럼을 가공했기 때문이다. 따라서 위 조건절을 처리할 때 인덱스에서 스캔하는 데이터량은 주문일자 조건을 만족하는 100만 건이다.
- 이를 두고, 인덱스를 잘 탄다고 말할 수 있을까? 

### 2.2.4 인덱스를 이용한 소트 연산 생략
- PK를 `장비번호 + 변경일자 + 변경순번` 순으로 구성한 상태변경이력 테이블이 있다고 하자. PK 인덱스에서 장비번호, 변경일자가 같은 레코드는 변경순번 순으로 정렬돼 있다.
- 장비번호와 변경일자를 모두 '=' 조건으로 검색할 때 PK 인덱스를 사용하면 결과집합은 변경순번 순으로 출력된다.
- 이럴 경우, 옵티마이저는 SQL에 ORDER BY가 있어도 정렬 연산을 따로 수행하지 않는다. PK 인덱스를 스캔하면서 출력한 결과집합은 어차피 변경순번 순으로 정렬되기 때문이다.
- 만약 정렬 연산을 생략할 수 있게 인덱스가 구성돼 있지 않다면, SORT ORDER BY 연산 단계가 추가된다.
- 내림차순(Desc) 정렬에도 인덱스를 활용할 수 있다. 왜냐하면 인덱스 리프 블록은 양방향 연결 리스트 구조이기 때문이다.
- 오름차순(Asc) 정렬일 때는 조건을 만족하는 가장 작은 값을 찾아 좌측으로 수직적 탐색한 후 우측으로 수평적 탐색을 한다.
- 내림차순 정렬일 때는 조건을 만족하는 가장 큰 값을 찾아 우측으로 수직적 탐색한 후 좌측으로 수평적 탐색을 한다.
- SQL에 ORDER BY절에서 내림차순을 요구할 경우 실행계획에 SORT ORDER BY 연산은 없지만, INDEX RANGE SCAN 단계에 DESCENDING을 확인할 수 있다.

### 2.2.5 ORDER BY 절에서 컬럼 가공
- "**인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다**"에서 말하는 **인덱스 컬럼**은 대개 조건절에 사용한 컬럼을 말한다. 그런데 조건절이 아닌 ORDER BY 또는 SELECT-LIST에서 컬럼을 가공함으로 인해 인덱스를 정상적으로 사용할 수 없는 경우도 종종 있다.

```
SELECT *
FROM 상태변경이력
WHERE 장비번호 = 'C'
ORDER BY 변경일자, 변경순번
```
- 상태변경이력 PK 인덱스를 `장비번호 + 변경일자 + 변경순번` 순으로 구성했다면 위 SQL도 정렬 연산을 생략할 수 있다.

```
SELECT *
FROM 상태변경이력
WHERE 장비번호 = 'C'
ORDER BY 변경일자 || 변경순번
```
- 만약 개발자가 SQL을 위와 같이 작성했다면, 정렬 연산을 생략할 수 없다. 인덱스에는 가공하지 않은 상태로 값을 저장했는데, 가공한 값 기준으로 정렬해 달라고 요청했기 때문이다.

```
SELECT *
FROM (
    SELECT TO_CHAR(A.주문번호, 'FM000000') AS 주문번호, A.업체번호, A.주문금액
    FROM 주문 A
    WHERE A.주문일자 = :dt
    AND A.주문번호 > NVL(:next_order_no, 0)
    ORDER BY 주문번호
)
WHERE ROWNUM <= 30
```
- 주문_PK 인덱스는 `주문일자 + 주문번호` 순으로 구성돼 있다. 위의 SQL에 주문_PK 인덱스를 사용하면 선두 컬럼인 주문일자가 '=' 조건이므로 데이터가 주문번호 순으로 출력된다. ORDER BY 절이 있어도 정렬 연산을 생략할 수 있는 상태다.
- 하지만 실행 계획에서는 SORT ORDER BY 연산이 나타나고 있다. 왜냐하면 ORDER BY 절에 기술한 '주문번호'는 순수한 주문번호가 아니라 TO_CHAR 함수로 가공한 주문번호를 가리키기 때문이다.

```
SELECT *
FROM (
    SELECT TO_CHAR(A.주문번호, 'FM000000') AS 주문번호, A.업체번호, A.주문금액
    FROM 주문 A
    WHERE A.주문일자 = :dt
    AND A.주문번호 > NVL(:next_order_no, 0)
    ORDER BY A.주문번호
)
WHERE ROWNUM <= 30
```
- 해결방법은 간단하다. 위와 같이 ORDER BY 절 주문번호에 A(주문 테이블 Alias)를 붙여주기만 하면 된다.

### 2.2.6 SELECT-LIST에서 컬럼 가공
- 인덱스를 `장비번호 + 변경일자 + 변경순번` 순으로 구성하면, 아래와 같이 변경순번 최소값을 구할 때도 옵티마이저는 정렬 연산을 따로 수행하지 않는다. 수직적 탐색을 통해 조건을 만족하는 가장 왼쪽 지점으로 내려가서 첫 번째 읽는 레코드가 바로 최소값이기 때문이다.
```
SELECT MIN(변경순번)
FROM   상태변경이력
WHERE  장비번호 = 'C'
AND    변경일자 = '20180316'
```

- 아래와 같이 변경순번 최대값을 구할 때도 정렬 연산을 수행하지 않는다. 최소값을 찾아 수직적 탐색할 때 왼쪽으로 내려갔다면, 최대값을 찾을 때는 오른쪽으로 내려가는 점만 다르다.
- 수직점 탐색을 통해 조건을 만족하는 가장 오른쪽 지점으로 내려가서 첫 번째 읽는 레코드가 바로 최대값이다.
```
SELECT MAX(변경순번)
FROM   상태변경이력
WHERE  장비번호 = 'C'
AND    변경일자 = '20180316'
```

- 인덱스를 이용해 정렬 연산 없이 최소 또는 최대값을 빠르게 찾을 때 인덱스 리프 블록의 왼쪽(MIN) 또는 오른쪽(MAX)에서 레코드 하나(FIRST ROW)만 읽고 멈춘다.
- 그런데 SQL을 아래와 같이 작성하면 정렬 연산을 생략할 수 없다. 인덱스에는 문자열 기준으로 정렬돼 있는데, 이를 숫자값으로 바꾼 값 기준으로 최종 변경순번을 요구했기 때문이다.
```
SELECT NVL(MAX(TO_NUMBER(변경순번)), 0)
FROM   상태변경이력
WHERE  장비번호 = 'C'
AND    변경일자 = '20180316'
```

- SQL을 아래와 같이 바꾸면 정렬 연산 없이 최종 변경순번을 쉽게 찾을 수 있다. 이렇게 변환하려면 변경순번 값이 고정너비로 입력돼 있어야 한다. 애초에 변경순번 데이터타입을 숫자형으로 설계했다면 이렇게 튜닝할 일이 없을 것이다.
```
SELECT NVL(TO_NUMBER(MAX(변경순번)), 0)
FROM   상태변경이력
WHERE  장비번호 = 'C'
AND    변경일자 = '20180316'
```

- 또다른 아래의 SQL은 장비구분코드 = 'A001'에 해당하는 장비들의 최종 변경일자를 스칼라 서브쿼리를 이용해 상태변경이력 테이블에서 조회하고 있다. 정렬 연산 없이 MIN/MAX, FIRST ROW 방식으로 실행하고 있음을 실행계획에서 확인할 수 있다.
```
SELECT 장비번호, 장비명, 상태코드
       , (SELECT MAX(변경일자)
          FROM   상태변경이력
          WHERE  장비번호 = P.장비번호) 최종변경일자
FROM   장비 P
WHERE  장비구분코드 = 'A001'
```

- 최종 변경일자에 더해 최종 변경순번까지 출력하려면 SQL을 어떻게 작성해야 할까? 아래와 같이 작성할 수 있지만, 상태변경이력 테이블을 여러 번 읽어야 하므로 비효율적이다.
- PK 컬럼이 더 많아지면 SQL문도 훨씬 더 복잡해지므로 성능도 나빠진다.
```
SELECT 장비번호, 장비명, 상태코드
       , (SELECT MAX(변경일자)
          FROM   상태변경이력
          WHERE  장비번호 = P.장비번호) 최종변경일자
       , (SELECT MAX(변경순번)
          FROM   상태변경이력
          WHERE  장비번호 = P.장비번호
          AND    변경일자 = (SELECT MAX(변경일자)
                            FROM   상태변경이력
                            WHERE   장비번호 = P.장비번호)) 최종변경순번
FROM   장비 P
WHERE  장비구분코드 = 'A001'
```

- 아래와 같이 작성하면 PK 컬럼이 많아져도 덜 복잡하다.
- 하지만 각 장비당 이력이 많지 않으면 크게 상관없지만, 이력이 많다면 성능에 문제가 될 수 있는 패턴이다. 인덱스 컬럼을 가공했기 때문이다.
```
SELECT 장비번호, 장비명, 상태코드
       , SUBSTR(최종이력, 1, 8) 최종변경일자
       , SUBSTR(최종이력, 9)    최종변경순번
FROM (
      SELECT 장비번호, 장비명, 상태코드
             , (SELECT MAX(변경일자 || 변경순번)
                FROM   상태변경이력
                WHERE  장비번호 = P.장비번호) 최종이력
      FROM 장비 P
      WHERE 장비구분코드 = 'A001'               
)
```

- 각 장비에 속한 과거 이력 데이터를 모두 읽어야 하므로 장비당 이력 레코드가 많다면 상태변경이력 테이블을 여러 번 읽는 복잡한 SQL보다 성능이 더 안 좋을 수 있다.
- 아래는 장비당 이력 레코드가 많은 상태에서 수집한 트레이스 결과다. 상태변경이력_PK 인덱스에서 1,825,000개 레코드를 읽으면서 6,830개 블록을 읽었다. 메인쿼리 장비 테이블에서는 읽은 데이터가 10건 밖에 안된다.
```
ROWS    ROW SOURCE OPERATION
------  ------------------------------------------------------------
     10 SORT AGGREGATE (cr=6830 pr=6488 pw=0 time=0 us)
1825000  INDEX RANGE SCAN 상태변경이력_PK (cr=6830 pr=6488 pw=0 ...)
     10 TABLE ACCESS BY INDEX ROWID 장비 (cr=4 pr=16 pw=0 time=0 us)
     10  INDEX RANGE SCAN 장비_N1 (cr=2 pr=8 pw=0 time=90 us)
```

- 이에 대한 해법을 공부하려면 Top N 알고리즘을 먼저 알아야 한다. (5.3.4 이력 조회에서 계속)

### 2.2.7 자동 형변환
```
SELECT * FROM 고객
WHERE 생년월일 = 19821225
```
- 고객 테이블에 생년월일이 선두 컬럼인 인덱스가 있다고 하자. 위 SQL은 생년월일 컬럼을 조건절에서 가공하지 않았는데도 옵티마이저는 테이블 전체 스캔을 수행했다.
- 그 이유는 옵티마이저가 SQL을 아래와 같이 변환했기 때문이다.
```
SELECT * FROM 고객
WHERE TO_NUMBER(생년월일) = 19821225
```
- 이는 고객 테이블 생년월일 컬럼이 문자형인데 조건절 비교값을 숫자형으로 표현했기 때문에 나타난 현상이다. 각 조건절에서 양쪽 값의 데이터 타입이 서로 다르면 값을 비교할 수 없다.
- 타입 체크를 엄격히 함으로써 컴파일 시점에 에러를 내는 DBMS도 있고, 자동으로 형변환 처리해주는 DBMS도 있다. 오라클은 후자이다.

```
SELECT * FROM 고객
WHERE 가입일자 = '01-JAN-2018';
```
- 위 SQL과 같이 날짜형(가입일자)과 문자형('01-JAN-2018')이 만나면 날짜형이 이긴다. 이 경우에는 좌변 컬럼 기준으로 우변을 변환하므로 인덱스 사용에 문제가 없다.

```
SELECT * FROM 고객
WHERE 가입일자 = TO_DATE('01-JAN-2018', 'DD-MON-YYYY');
```
- NLS_DATE_FORMAT 파라미터가 다르게 설정된 환경에서 수행하면 컴파일 오류가 나거나 결과집합이 틀려질 수 있다. 위와 같이 날짜 포맷을 정확히 지정해 주는 습관이 필요하다.

```
SELECT * FROM 고객
WHERE 고객번호 LIKE '9410%'

Predicate information (identified by opration id):
1 - filter(TO_CHAR("고객번호") LIKE '9410%')
```
- 숫자형과 문자형이 만나면 숫자형이 이긴다고 했지만, 연산자가 LIKE일 때는 다르다. LIKE 자체가 문자열 비교 연산자이므로 이때는 문자열 기준으로 숫자형 컬럼이 변환된다.

```
-- SQL1 : 사용자가 계좌번호를 입력할 경우
SELECT * FROM 거래
WHERE 계좌번호 = :acnt_no
AND   거래일자 between :trd_dt1 and :trd_dt2

-- SQL2 : 사용자가 계좌번호를 입력하지 않을 경우
SELECT * FROM 거래
WHERE 거래일자 between :trd_dt1 and :trd_dt2
```
- 위 SQL을 하나로 처리하기 위해 아래와 같이 LIKE 조건을 사용하는 경우가 있다.
```
SELECT * FROM 거래
WHERE 계좌번호 LIKE :acnt_no || '%'
AND   거래일자 between :trd_dt1 and :trd_dt2
```
- 이 방식을 사용하면 LIKE, BETWEEN 조건을 같이 사용했으므로 인덱스 스캔 효율이 안 좋아진다. 계좌번호 컬럼이 숫자형일 때 특히 주의가 필요하다. 숫자형 컬럼을 LIKE 조건으로 검색하면 자동 형변환이 발생해 계좌번호가 아예 인덱스 액세스 조건으로 사용되지 못하기 때문이다.
- 계좌번호가 형변환되면 `계좌번호 + 거래일자` 순으로 구성된 인덱스를 Range Scan 할 수 없다. `거래일자 + 계좌번호` 순으로 구성된 인덱스는 Range Scan 할 수 있지만, 인덱스 스캔 효율은 매우 안 좋아진다. 왜냐하면 거래일자 조회 범위에 속한 거래 데이터를 모두 읽으면서 계좌번호를 필터링하기 때문이다.

#### 자동 형변환 주의
```
where n_col = v_col
              *
2행에 오류:
ORA-01722: 수치가 부적합합니다
```
- 위와 같이 숫자형 컬럼(n_col)에 문자형 컬럼(v_col)을 비교하면 문자형 컬럼이 숫자형으로 변환되는데, 만약 문자형 컬럼에 숫자로 변환할 수 없는 문자열이 입력되면 쿼리 수행 도중 에러가 발생한다.

```
SELECT ROUND(AVG(SAL)) AVG_SAL
, MIN(SAL) MIN_SAL
, MAX(SAL) MAX_SAL
, MAX(DECODE(JOB, 'PRESIDENT', NULL, SAL)) MAX_SAL2
FROM EMP2;

AVG_SAL MIN_SAL MAX_SAL MAX_SAL2
------- ------- ------- --------
2073    800     5000    950
```
- 실행 에러가 아니라 결과 오류가 생기는 사례도 있다. 위와 같이 EMP 테이블에서 직원들 급여 수준을 조회해 보았다.
- 가장 적게 받는 직원 급여가 800이고, 가장 많이 받는 직원 급여는 5,000이다. 가장 많이 받는 직원은 당연히 'PRESIDENT'일 것으로 예상되므로 이를 제외하고 가장 많이 받는 직원의 급여(MAX_SAL2)도 함께 조회했다. 그런데 그 값이 평균 급여인 2,073에도 못 미치는 950으로 나타났다.

```
SELECT EMPNO, ENAME, JOB, SAL
FROM   JOB
WHERE  JOB <> 'PRESIDENT'
ORDER BY SAL DESC ;

EMPNO ENAME JOB     SAL
----- ----- ------- ----
7902  FORD  ANALYST 3000
7788  SCOTT ANALYST 3000
7566  JONES MANAGER 2975
...   ...   ...
```
- 레코드 단위로 조회해 보니 'PRESIDENT'를 제외한 두 명의 'ANALYST' 급여가 3,000으로 가장높았다.
- 앞의 집계 쿼리에서 엉뚱한 값이 나온 이유는 오라클이 DECODE 함수를 처리할 때 내부에서 사용하는 자동 형변환 규칙 때문이다.
- DECODE(A, B, C, D)를 처리할 때 'A = B'이면 C를 반환하고, 아니면 D를 반환한다. 이때 반환값의 데이터 타입은 세 번째 인자 C에 의해 결정된다. 따라서 C가 문자형이고 D가 숫자형이면, D는 문자형으로 변환된다.
- DECODE 함수가 가진 또 하나의 내부 규칙은 세 번째 인자(C)가 NULL 값이면 VARCHAR2로 취급한다는 사실이다.
- 앞의 집계 쿼리에서 세 번째 인자가 NULL 값이므로 네 번째 인자 SAL을 문자열로 변환하고, 문자열 기준으로 가장 큰 값(950)을 출력한 것이다. 아래와 같이 데이터 타입을 명시적으로 일치시켜 주면 위와 같은 오류를 피할 수 있다.
- TO_NUMBER(NULL) 대신 0을 써도 된다.
```
SELECT ROUND(AVG(SAL)) AVG_SAL
, MIN(SAL) MIN_SAL
, MAX(SAL) MAX_SAL
, MAX(DECODE(JOB, 'PRESIDENT', TO_NUMBER(NULL), SAL)) MAX_SAL2
FROM EMP2;

AVG_SAL MIN_SAL MAX_SAL MAX_SAL2
------- ------- ------- --------
2073    800     5000    3000
```
- 자동 형변환에 대한 결론은 이 기능에 의존하지 말고, 인덱스 컬럼 기준으로 반대편 컬럼 또는 값을 정확히 형변환해 주어야 한다.

## 2.3 인덱스 확장기능 사용법