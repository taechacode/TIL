# 정규형
## 정규형의 종류
- `정규화`는 테이블에 대한 삽입, 삭제, 수정 등의 연산으로 발생할 수 있는 이상현상을 방지하는 수단을 제공해 준다.
- 이상현상에는 여러 유형이 존재하며, 이러한 문제들을 어느 수준까지 해결해주느냐에 따라 정규화도 여러 단계가 있다.
- 그리고 각 단계별 정규화 과정을 통해 분해된 테이블들을 `정규형(normal form)`이라고 한다.
<br>

- 정규형에는 `1차 정규형(1NF:first normal form)`에서부터 `5차 정규형(5NF:fifth normal form)`까지 있으며 정규형의 차수가 높아질수록 더 많은 제약들이 가해진다.
- 이외에도 특수항 정규형인 `보이스-코드 정규형(BCNF:Boyce-Codd normal form)`이 있다.
<br>

![정규형의 종류와 이들 간의 관계](https://github.com/taechacode/TIL/assets/63395751/a8c182bf-3202-4703-89c0-0a34110d1ca6)
<br>

- 각 정규형의 관계는 위의 그림에서 보는 바와 같이 중첩된 관계를 갖는다.
- 즉, 2차 정규형 테이블은 1차 정규형에 속하고 3차 정규형 테이블은 1차와 2차 정규형에 속한다.
- 일반적으로 데이터베이스를 설계할 때는 3차 정규형이나 보이스-코드 정규형까지만을 고려하며, 4차나 5차 정규형에 대해서는 거의 고려하지 않는다.
<br>

### 1차 정규형
- 1차 정규형은 다음과 같이 정의된다.
```
테이블 R에 속한 모든 도메인이 원자값(atomic value)만으로 구성되어 있다면 R은 1차 정규형이다.
```
- 관계형 데이터 모델은 테이블 형태의 데이터 구조로 구성되며, 각 레코드에서 필드값은 배열이나 집합값이 아닌 원자값만을 갖는다.
- 따라서 관계형 데이터 모델의 정의를 따르는 모든 테이블들을 1차 정규형이라 할 수 있다.
<br>

![register 테이블 (1차 정규형)](https://github.com/taechacode/TIL/assets/63395751/b3ba1e71-d2b5-44f1-a526-7fc04bc04d2a)
<br>

- register 테이블은 위와 같다.
- 이 테이블은 각 학생이 수강하고 있는 과목과 그 과목에 대한 성적, 그리고 학생이 소속된 학과와 사무실 정보를 저장한다.
- 여기서 기본키는 (stu_id, title)의 복합키로 구성된다.
- 이 테이블에 대해서 다음과 같은 함수적 종속들이 정의되어 있다고 가정하자.
  - (stu_id, title) -> grade
  - stu_id -> dept_name
  - dept_name -> office
- 이 테이블은 위의 정의에 의해 1차 정규형임을 쉽게 알 수 있다.
<br>

### 2차 정규형
- 1차 정규형은 3가지 이상현상이 발생할 수 있다.
  - **삽입 이상** : 학번이 '1292502'인 학생이 '전자공학과'에 소속된다는 사실을 삽입하려면 최소한 그 학생이 하나의 과목을 수강해야만 가능하다. 그렇지 않은 경우 삽입이 불가능하다.
  - **삭제 이상** : 이 테이블에서 stu_id가 '1292301'인 학생이 '자료구조'를 수강한다는 사실을 삭제하면 이 학생이 '산업공학과'에 소속된다는 정보까지 동시에 삭제된다. 뿐만 아니라, 이 학생이 '산업공학과'에 유일한 학생이라면 학과정보도 같이 삭제된다.
  - **수정 이상** : 학번이 '1292001'인 학생의 소속이 '컴퓨터공학과'에서 '산업공학과'로 변경되었다고 가정하자. 그러면 이 사실에 해당하는 모든 레코드에 대해서 반영해야 한다.
- 이러한 문제가 발생하는 이유는 테이블에서 stu_id는 기본키의 일부인데 이 필드가 기본키에 포함되지 않은 필드인 dept_name을 함수적으로 결정한다.
- 따라서 dept_name 필드는 기본키인 (stu_id, title)에 의해 영향을 받지 않고 오직 stu_id에 의해서만 결정된다.
- 결국 dept_name은 이 테이블에서 중복되어 표현될 수 밖에 없으므로 이상현상이 발생하는 것이다.
<br>

![부분 종속 및 2차 정규형으로 분해](https://github.com/taechacode/TIL/assets/63395751/bc0f4d73-c413-428f-b219-df9db82e280f)
<br>

- 일반적으로 표현하면 함수적 종속 중에서 키에 포함되지 않은 필드가 키의 부분 집합에 의해 함수적으로 결정된다면 위와 같은 이상현상이 발생할 수 있다.
- 이와 같이 키에 포함되지 않은 필드가 키의 부분집합에 종속되는 것을 `부분 종속(partial dependency)`이라고 한다.
- 위의 그림은 부분 종속의 예를 보여준다. 이 그림에서 X는 키의 부분집합이고, X -> A가 성립하면 A는 키에 부분 종속된다.
<br>

- 여기서 이상현상을 해결하기 위해서는 부분 종속에 해당하는 결정자와 종속자를 별도의 테이블로 분리시켜야 한다.
- 즉, X와 A를 하나의 독립된 테이블로 구성하고 본래의 테이블에서 A를 제외하면 된다.
<br>

![(a) student 테이블](https://github.com/taechacode/TIL/assets/63395751/1929cc26-94bf-48c8-b1b5-1f3851e1b8a1)
#### (a) student 테이블
<br>

![(b) takes 테이블](https://github.com/taechacode/TIL/assets/63395751/3540bf0a-8b1d-453a-a88a-795cf38c6c5a)
#### (b) takes 테이블
<br>

- register 테이블을 위와 같이 student와 takes 테이블로 분해한 결과로 나타낸다.
- 분해가 이루어지면 다음과 같이 더 이상 이상현상이 발생하지 않는다.
  - **삽입 이상** : 학번이 '1292502'인 학생이 '전자공학과'에 소속된다는 레코드를 student 테이블에 삽입할 수 있다.
  - **삭제 이상** : 학번이 '1292301'인 학생이 '자료구조'를 수강한다는 사실을 삭제하려면, takes 테이블에서 해당 레코드를 삭제하면 된다. 이 학생이 '산업공학과'에 소속한다는 사실을 student 테이블에 보존된다.
  - **수정 이상** : 학번이 '1292001'인 학생의 소속이 '컴퓨터공학과'에서 '산업공학과'로 변경하기 위해, student 테이블에서 변경하면, 데이터 중복이 발생하지 않아 더 이상 데이터 불일치 문제가 발생하지 않는다.
<br>

- 분해된 student와 takes 테이블에는 다음과 같이 함수적 종속이 그대로 보존됨을 알 수 있다.
  - student 테이블의 함수적 종속
    - stu_id -> dept_name
    - dept_name -> office
  - takes 테이블의 함수적 종속
    - (stu_id, title) -> grade
<br>

- student 테이블에 존재하는 함수적 종속을 보면, stu_id는 dept_name과 office를 함수적으로 결정하므로 stu_id는 student 테이블에서 키가 된다.
- 유사하게 takes 테이블의 경우에는 (stu_id, title)이 takes 테이블의 키가 된다.
- 이렇게 분해된 각 테이블에서 키에 대한 부분 종속이 존재하지 않음을 알 수 있다.
- 2차 정규형은 다음과 같이 정의된다.
```
테이블 R에서 키가 아닌 모든 필드가 키에 대해 함수적으로 종속되며,
키의 부분 집합이 결정자가 되는 부분 종속이 존재하지 않으면, R은 2차 정규형이다.
```
- 이 정의에 따르면 하나의 필드로 키가 정의되는 경우는 모두 2차 정규형이다.
- 키가 하나의 필드로 구성되면 부분 종속이 발생할 수 없기 때문이다.
