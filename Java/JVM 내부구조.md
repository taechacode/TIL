# JVM 내부구조(Internal)
- 자바는 자바 바이트코드가 JRE 위에서 동작한다. JRE에서 가장 중요한 요소는 자바 바이트코드를 해석하고 실행하는 `JVM(Java Virtual Machine)`이다.
- JRE는 자바 API와 JVM으로 구성되며, JVM의 역할은 자바 애플리케이션을 `클래스 로더(Class Loader)`를 통해 읽어 들여서 자바 API와 함께 실행하는 것이다.

<br/>

## 가상 머신
- 가상 머신(Virtual Machine)이란 프로그램을 실행하기 위해 물리적 머신(컴퓨터)과 유사한 머신을 소프트웨어로 구현한 것이다.
- 자바는 원래 WORA(Write Once Run Anywhere)를 구현하기 위해 물리적인 머신과 가상 머신을 기반으로 동작하도록 설계되었다.
- 그래서 자바 바이트코드를 실행하고자 하는 모든 하드웨어에 JVM을 동작시킴으로써 자바 실행 코드를 변경하지 않고도 모든 종류의 하드웨어에서 동작되게 한 것이다.

### JVM의 특징
- **스택 기반의 가상 머신** : 대표적인 컴퓨터 아키텍처인 인텔 x86 아키텍처나 ARM 아키텍처와 같은 하드웨어가 레지스터 기반으로 동작하는 데 비해 JVM은 스택 기반으로 동작한다.
- **심볼릭 레퍼런스** : 기본 자료형(Primitive data type)을 제외한 모든 타입(클래스와 인터페이스)을 명시적인 메모리 주소 기반의 레퍼런스가 아니라 심볼릭 레퍼런스를 통해 참조한다.
- **가비지 컬렉션(Garbage Collection)** : 클래스 인스턴스는 사용자 코드에 의해 명시적으로 생성되고 가비지 컬렉션에 의해 자동으로 파괴된다.
- **기본 자료형을 명확하게 정의하여 플랫폼 독립성 보장** : C/C++ 등의 전통적인 언어는 플랫폼에 따라 int형의 크기가 변한다. JVM은 기본 자료형을 명확히 정의하여 호환성을 유지하고 플랫폼 독립성을 보장한다.
- **네트워크 바이트 오더(Network Byte Order)** : 자바 클래스 파일은 네트워크 바이트 오더를 사용한다. 인텔 x86 아키텍처가 사용하는 리틀 엔디안이나, RISC 계열 아키텍처가 주로 사용하는 빅 엔디안 사이에서 플랫폼 독립성을 유지하려면 고정된 바이트 오더를 유지해야 하므로 네트워크 전송 시에 사용하는 바이트 오더인 네트워크 바이트 오더를 사용한다. 네트워크 바이트 오더는 빅 엔디안이다.

<br/>

## JVM 구조

### 자바 코드 수행 과정

<br/>

![자바 코드 수행 과정](https://github.com/taechacode/TIL/assets/63395751/70e647f5-08d3-497a-af97-f8ab6fb11a07)

<br/>

## 클래스 로더
&nbsp;자바는 동적 로드, 즉 컴파일타임이 아니라 런타임에 클래스를 처음으로 참조할 때 해당 클래스를 로드하고 링크하는 특징이 있다. 이 동적 로드를 담당하는 부분이 JVM의 클래스 로드이다. 자바 클래스 로더의 특징은 아래와 같다.
- **계층 구조** : 클래스 로더끼리 부모-자식 관계를 이루어 계층 구조로 생성된다. 최상위 클래스 로더는 부트스트랩 클래스 로더(Bootstrap Class Loader)이다.
- **위임 모델** : 계층 구조를 바탕으로 클래스 로더끼리 로드를 위임하는 구조로 동작한다. 클래스를 로드할 때 먼저 상위 클래스 로더를 확인하여 상위 클래스 로더에 있다면 해당 클래스를 사용하고, 없다면 로드를 요청받은 클래스 로더가 클래스를 로드한다.
- **가시성(Visibility) 제한** : 하위 클래스 로더는 클래스를 로드할 수는 있지만 언로드할 수는 없다. 언로드 대신, 현재 클래스를 삭제하고 아예 새로운 클래스 로더를 생성하는 방법을 사용할 수 있다.

<br/>

&nbsp;각 클래스 로더는 로드된 클래스들을 보관하는 네임스페이스(namespace)를 갖는다. 클래스를 로드할 때 이미 로드된 클래스인지 확인하기 위해서 네임스페이스에 보관된 FQCN(Full Qualified Class Name)을 기준으로 클래스를 찾는다. 비록 FQCN이 갖더라도 네임스페이스가 다르면, 즉 다른 클래스 로더가 로드한 클래스이면 다른 클래스로 간주된다.

<br/>

### 클래스 로더 위임 모델

<br/>

![클래스 로더 위임 모델](https://github.com/taechacode/TIL/assets/63395751/8bb1ec91-495c-4106-9828-0ae372d95a30)

<br/>

### 로딩 요청 위임 (Delegate Load Request)

<br/>

![Delegate Load Request](https://github.com/taechacode/TIL/assets/63395751/54aeb8e9-11b1-4a81-af13-642f467512d2)

<br/>

&nbsp;클래스 로더가 클래스 로드를 요청받으면, 클래스 로더 캐시 -> 상위 클래스 로더 -> 자기 자신의 순서로 해당 클래스가 있는지 확인한다. 즉, 이전에 로드된 클래스인지 클래스 로더 캐시를 확인하고, 없으면 상위 클래스 로더를 거슬러 올라가며 확인한다. 부트스트랩 클래스 로더까지 확인해도 없으면 요청받은 클래스 로더가 파일 시스템에서 해당 클래스를 찾는다.

- **부트스크랩 클래스 로더** : JVM을 기동할 때 생성되며, Object 클래스들을 비롯하여 자바 API들을 로드한다. 다른 클래스 로더와 달리 자바가 아니라 네이티브 코드로 구현되어 있다.
- **익스텐션 클래스 로더(Extension Class Loader)** : 기본 자바 API를 제외한 확장 클래스들을 로드한다. 다양한 보안 확장 기능 등을 여기서 로드하게 된다.
- **시스템 클래스 로더(System Class Loader)** : 부트스트랩 클래스 로더와 익스텐션 클래스 로더가 JVM 자체의 구성 요소들을 로드하는 것이라 한다면, 시스템 클래스 로더는 애플리케이션의 클래스들을 로드한다고 할 수 있다. 사용자가 지정한 $CLASSPATH 내의 클래스들을 로드한다.
- **사용자 정의 클래스(User-Defined Class Loader)** : 애플리케이션 사용자가 직접 코드 상에서 생성해서 사용하는 클래스 로더이다.

<br/>

&nbsp;웹 애플리케이션 서버(WAS)와 같은 프레임워크는 웹 애플리케이션들, 엔터프라이즈 애플리케이션들이 서로 독립적으로 동작하기 위해 사용자 정의 클래스 로더를 사용한다. 즉, 클래스 로더의 위임 모델을 통해 애플리케이션의 독립성을 보장하는 것이다. 이와 같은 WAS의 클래스 로더 구조는 WAS 벤더마다 조금씩 다른 형태의 계층 구조를 사용하고 있다.

<br/>

### 클래스 로드 단계

<br/>

![클래스 로드 단계](https://github.com/taechacode/TIL/assets/63395751/7f7b4757-fcbe-4f4d-a007-5dca6cdf2bba)

<br/>

&nbsp;클래스 로더가 아직 로드되지 않은 클래스를 찾으면, 위 그림과 같은 과정을 거쳐 클래스를 로드하고 링크하고 초기화한다.

- **로드** : 클래스를 파일에서 가져와서 JVM의 메모리에 로드한다.
- **검증(Verifying)** : 읽어들인 클래스가 자바 언어 명세(Java Language Specification) 및 JVM 명세에 명시된 대로 잘 구성되어 있는지 검사한다. 클래스 로드의 전 과정 중에서 가장 까다로운 검사를 수행하는 과정으로서 가장 복잡하고 시간이 많이 걸린다. JVM TCK의 테스트 케이스 중에서 가장 많은 부분이 잘못된 클래스를 로드하여 정상적으로 검증 오류를 발생시키는지 테스트하는 부분이다.
- **준비(Preparing)** : 클래스가 필요로 하는 메모리를 할당하고, 클래스에서 정의된 필드, 메서드, 인터페이스들을 나타내는 데이터 구조를 준비한다.
- **분석(Resolving)** : 클래스의 상수 풀 내 모든 심볼릭 레퍼런스를 다이렉트 레퍼런스로 변경한다.
- **초기화** : 클래스 변수들을 적절한 값으로 초기화한다. 즉, static initializer들을 수행하고, static 필드들을 설정된 값으로 초기화한다.
