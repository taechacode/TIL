# SSL 통신과정

## SSL 암호화 종류

### 대칭키
- '대칭키 방식`은 **동일한 키**로 **암호화와 복호화**를 할 수 있는 기법을 말한다.
  - 예) 123을 사용하여 암호화하였다면 복호화도 123을 입력해야 가능하다.
- 암호화를 할 때 사용하는 **비밀번호**를 `키(key)`라고 한다.
- 이 키에 따라서 암호화된 결과가 달라지기 때문에 키를 모른다면 복호화도 할 수 없다.

<br/>

- 클라이언트와 서버는 대화를 하기 위해서 반드시 **대칭키**를 알고 있어야 한다. 그렇기 때문에 통신을 하기에 앞서 키를 전달하는 과정이 필요하다. (`키 배송 문제`)
- 그런데 만약 중간에 대칭키가 유출된다면 키를 획득한 공격자는 암호화된 데이터를 복호화하여 볼 수 있는 위험이 있다.
- 이런 단점을 보완하기 위해 나온 방식이 `공개키 방식`이다.

### 공개키
- '공개키 방식`은 대칭키 방식과 다르게 **2개의 키**를 가지고 시작한다.
- 그 중 하나는 `공개키(Public Key)`, 나머지 키를 `비밀키(Private Key, 개인키/비밀키)`라 부른다.
- **비밀키**는 자신만이 소지하고, **공개키**는 타인에게 제공한다.

<br/>

- 공개키로 암호화하면 비밀키로 복호화한다.
- 비밀키로 암호화하면 공개키로 복호화한다.
  - (1) 클라이언트가 **서버의 공개키**를 가지고 1234(정보)를 **암호화**하여 서버에게 !@#$라는 텍스트를 전달한다.
  - (2) 서버는 클라이언트가 보낸 !@#$라는 단어를 **비밀키**로 **복호화**하여 1234라는 것을 확인한다.

<br/>

- 일반적으로는 공개키로 암호화하고 비밀키로 복호화한다고 한다. 하지만 비밀키로 암호화하고 공개키로 복호화한다는 말도 틀린 것은 아니다.
- 공개키를 A, 비밀키를 B라고 했을 때 **A키로 암호화한 데이터를 B키로 복호화**하는 개념으로 생각하자. 즉, 키를 공개키로 부르냐 비밀키로 부르냐의 차이가 있을 뿐 데이터의 보안을 위해 사용되는 키라는 점에서는 동일하다.
- 공개키는 공개되어 있으며 보통 `디지털 인증서` 안에 포함되어 있다. 그렇기 때문에 공개키가 존재한다는 것은 서버의 신원이 안전하다고 볼 수 있다. 이것을 `전자서명`이라고 부른다.

<br/>

- 공개키 암호화 방식의 알고리즘은 계산이 느리다는 단점이 있다.

<br/>

## SSL 통신과정

<br/>

![SSL통신과정](https://github.com/taechacode/TIL/assets/63395751/2f05ac54-6cd2-4ce5-a316-5f88c2ea3afd)

<br/>

- 통신을 하기 위해서 `핸드셰이크 -> 세션 -> 세션종료`의 과정을 거친다.
- 암호화된 HTTP 메시지를 교환하기 전에 **클라이언트와 서버**는 **SSL 핸드셰이크**를 진행한다.
- SSL 핸드셰이크에서 핵심은 **공개키와 대칭키 2가지 방법을 함께 사용**한다는 점이다.

### Step 1
- Client Hello : 서버에 접근한다.
  - 클라이언트는 **랜덤한 데이터**와 **현재 지원가능한 암호화 방식**을 서버에게 전달한다.

### Step 2
- Server Hello : 서버가 응답한다.
  - 서버는 3가지를 응답한다 : 공개키가 들어있는 `인증서`, 서버에서 생성한 `랜덤한 데이터`, `가장 안전한 암호화 수단 방식`

### Step 3
- 클라이언트는 브라우저에 내장되어 있는 CA 리스트에서 각 `CA의 공개키`를 이요하여 서버가 보낸 **인증서**를 복호화한다.
- 만약 CA 리스트에 없는 인증서라면 사용자에게 경고 메시지를 띄운다.
- 만약 복호화를 성공했을 경우 해당 인증서는 CA의 비밀키로 암호화한 문서임을 나타내는 것이기에 서버를 신뢰할 수 있게된다. (비밀키로 암호화 -> 공개키로 복호화)
- 그리고 클라이언트가 전송한 랜덤한 데이터와 서버가 전송한 랜덤한 데이터를 조합하여 `Pre Master Secret 키`를 생성한다.

### Step 4
- Step 2에서 받는 **공개키**를 이용하여 Pre Master Secret 키를 암호화하여 서버로 전송한다. (공개키는 인증서에 포함되어 있다)
- 이 때 Pre Master Secret 키는 절대 노출되어서는 안된다.
- 서버는 Pre Master Secret 값을 **자신의 비밀키로 복호화**하고 이로써 클라이언트와 서버는 Pre Master Secret 키를 **공유**하게 된다.

### Step 5
- 서버와 클라이언트는 일련의 과정을 거쳐 Pre Master Secret 값을 **Master Secret** 값으로 만들고, Master Secret 값을 이용하여 **Session Key**를 만든다.

### Step 6
- 서버와 클라이언트 간의 세션이 형성되고 Session Key를 이용하여 데이터를 암호화하여 주고 받는다. 즉, **대칭키 방식**으로 데이터를 주고 받는다.

### 결과
- 대칭키는 공개키에 비해 빠르지만 `키 배송 문제`가 존재한다.
- 그렇기 때문에 SSL 핸드셰이크 과정에서는 Key를 공유하기 위해 공개키 방식을 사용하였고, 세션이 형성된 후에는 대칭키 방식으로 효율을 높였다.

<br/>

***출처 : https://goodgid.github.io/TLS-SSL/***
