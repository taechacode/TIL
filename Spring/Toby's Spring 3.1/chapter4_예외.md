# 4장 예외
## 4.1 사라진 SQLException
```
public void deleteAll() throws SQLException {
    this.jdbcContext.executeSql("delete from users");
}
```
**JdbcTemplate 적용 전**
<br/><br/>

```
public void deleteAll() {
    this.jdbcTemplate.update("delete from users");
}
```
**JdbcTemplate 적용 후**
<br/><br/>

- JdbcTemplate 적용 전에는 있었던 throws SQLException이 선언이 적용 후에는 사라졌다.
- SQLException은 JDBC API의 메소드들이 던지는 것이므로 당연히 있어야 한다.
- 비록 로그를 남기기 위해 catch를 했다고 해도 다시 JDBC 템플릿 메소드 밖으로 던져서 예외상황이 발생했다는 사실을 알려야 한다.
- 이 SQLException은 어디로 사라진 것일까?
<br/>



### 4.1.1 초난감 예외처리

### 예외 블랙홀
<br/>

```
try {
    ...
} catch(SQLException e) {
}
```
**초난감 예외처리 코드 1**
<br/><br/>

- JDBC API를 썼더니 IDE가 친절하게도 빨간 줄을 그어주며 '처리되지 않은 예외가 있다'라고 에러 표시를 해준다. 이를 보고 자바 언어 기초 시간에 배운 대로 try/catch 블록을 둘러싸주는 것으로 해결한다. 컴파일러 에러 메시지도 없어지고 간단한 예제에서라면 별문제 없이 잘 동작한다.
- 위의 예시 코드 또한 예외를 잡고는 아무것도 하지 않는다. 예외 발생을 무시해버리고 정상적인 상황인 것처럼 다음 라인으로 넘어가겠다는 분명한 의도가 있는 게 아니라면 `연습 중에도 절대 만들어서는 안되는 코드다.`
<br/>

- 예외가 발생하면 그것을 catch 블록을 써서 잡아내는 것까지는 좋은데 아무것도 하지 않고 별문제 없는 것처럼 넘어가 버리는 건 원치 않는 예외가 발생하는 것보다도 훨씬 더 나쁜 일이다.
- 왜냐하면 프로그램 실행 중에 `어디선가 오류가 있어서 예외가 발생했는데 그것을 무시하고 계속 진행해버리기 때문`이다.
- 결국 발생한 예외로 인해 어떤 기능이 비정상적으로 동작하거나, 메모리가 리소스가 소진되거나, 예상치 못한 다른 문제를 일으킬 것이다.
- 최종적으로 오작동을 하거나 시스템 오류가 나서 운영자가 알아차렸을 때는 이미 조치를 취하기엔 너무 늦었다.
- 더 큰 문제는 그 시스템 오류나 이상한 결과의 원인이 무엇인지 찾아내기가 매우 힘들다는 것이다.
<br/>

```
} catch(SQLException e) {
    System.out.println(e);
}
```
**초난감 예외처리 코드 2**
<br/><br/>

```
} catch(SQLException e) {
    e.printStackTrace();
}
```
**초난감 예외처리 코드 3**
<br/><br/>

***예외가 발생하면 화면에 출력해주는데 뭐가 문제일까?***

- 개발 중에는 IDE 콘솔이나 서버 실행창에 이 메시지가 눈에 띄게 보이므로 문제가 생겨도 금방 알아차리고 뭔가 조치를 취할 수 있다.
- 하지만 다른 로그나 메시지에 금방 묻혀버리면 놓치기 쉽상이며, 운영 서버에서는 콘솔 로그를 누군가가 계속 모니터링하지 않는 한 예외 코드는 심각한 폭탄으로 남게 된다.
- `예외는 반드시 처리되어야 한다.`
<br/>

- 예외를 처리할 때 반드시 지켜야 할 핵심 원칙은 `모든 예외는 적절하게 복구되든지 아니면 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보되어야 한다.`
- SQLException이 발생하는 이유는 SQL에 문법 에러가 있거나 DB에서 처리할 수 없을 정도로 데이터 액세스 로직에 심각한 버그가 있거나, 서버가 죽거나 네트워크가 끊기는 등의 심각한 상황이 벌어졌기 때문이다.
- 그런데 그냥 예외를 무시하고 정상적으로 동작하고 있는 것처럼 모른 척 다음 코드로 실행을 이어간다는 건 말이 되지 않는다. 콘솔이나 로그에 예외 메시지를 출력만 하고 끝내는 것은 아무런 도움이 되지 않는다.
<br/>

```
} catch(SQLException e) {
    e.printStackTrace();
    System.exit(1);
}
```
**그나마 나은 예외처리**
<br/><br/>

- 위의 예시가 모범적인 것은 아니지만, 예외를 무시하거나 잡아먹어 버리는 코드는 만들지 말라는 뜻이다.
- 굳이 예외를 잡아서 뭔가 조치를 취할 방법이 없다면 잡지 말아야 한다.
- 메소드에 throws SQLException을 선언해서 메소드 밖으로 던지고 자신을 호출한 코드에 예외처리 책임을 전가해버리자.
<br/>


### 무의미하고 무책임한 throws
- catch 블록으로 예외를 잡아봐야 해결할 방법도 없고 JDK API나 라이브러리가 던지는 각종 이름도 긴 예외들을 처리하는 코드를 매번 throws로 선언하기 귀찮아지기 시작하면, 아래와 같이 throws Exception을 메소드 선언에 기계적으로 붙이는 개발자도 있다.
<br/>

```
public void method1() throws Exception {
    method2();
    ...
}

public void method2() throws Exception {
    method3();
    ...
}

public void method3() throws Exception {
    ...
}
```
**초난감 예외처리 4**
<br/><br/>

- EJB(!!)가 한창 쓰이던 시절에 흔히 볼 수 있던 코드다.
- throws Exception을 이용해 모든 예외를 무조건 던져버리는 선언을 모든 메소드에 기계적으로 넣는 것이다.
- 사용하려는 메소드에 throws Exception이 선언되어 있으면, 그런 메소드 선언에서는 의미 있는 정보를 얻을 수 없다. 정말 무엇인가 실행 중에 예외적인 상황이 발생할 수 있다는 것인지, 아니면 습관적으로 복사해서 붙여넣은 것은지 알 수가 없다. 결국 이런 메소드를 사용하는 메소드에서도 throws Exception을 따라서 붙이는 수밖에 없다.
<br/>



### 4.1.2 예외의 종류와 특징
- 예외를 어떻게 다뤄야 할까? 가장 큰 이슈는 **체크 예외 checked exception**라고 불리는 명시적인 처리가 필요한 예외를 사용하고 다루는 방법이다.
- Java에서 throw를 통해 발생시킬 수 있는 예외는 크게 3가지가 있다.
<br/>

#### Error
- 첫번째는 java.lang.Error 클래스의 서브클래스들이다.
- 에러는 시스템에 뭔가 비정상적인 상황이 발생했을 경우에 사용된다.
- 그래서 주로 Java VM에서 발생시키는 것이고 애플리케이션 코드에서 잡으려고 하면 안 된다.
- OOM(OutOfMemoryError)나 ThreadDeath 같은 에러는 catch 블록으로 잡아봤자 아무런 대응 방법이 없기 때문이다.
- 따라서 시스템 레벨에서 특별한 작업을 하는 게 아니라면 애플리케이션에서는 이런 에러에 대한 처리는 신경 쓰지 않아도 된다. (사전에 방지할 수 있는 문제는 코드로 막는게 좋지 않...나?)
<br/>

#### Exception과 체크 예외
- java.lang.Exception 클래스와 그 서브클래스로 정의되는 예외들은 에러와 달리 개발자들이 만든 애플리케이션 코드의 작업 중에 예외상황이 발생했을 경우에 사용된다.
- Exception 클래스는 다시 체크 예외와 **언체크 예외 unchecked exception**으로 구분된다. 전자는 Exception 클래스의 서브클래스이면서 RuntimeException 클래스를 상속하지 않은 것들이고, 후자는 RuntimeException을 상속한 클래스들을 말한다.
- RuntimeException은 Exception의 서브클래스이므로 Exception의 일종이긴 하지만 Java는 이 RuntimeException과 그 서브클래스는 특별하게 다룬다.
<br/>

![Exception의 두 가지 종류](https://github.com/taechacode/TIL/assets/63395751/70343f33-58ae-49e2-93f2-800a187e6e0c)
**Exception의 두 가지 종류**
<br/>

- 일반적으로 예외라고 하면 Exception 클래스의 서브클래스 중에서 RuntimeException을 상속하지 않은 것만을 말하는 체크 예외라고 생각해도 된다.
- 체크 예외가 발생할 수 있는 메소드를 사용할 경우 반드시 예외를 처리하는 코드를 함께 작성해야 한다.
- 사용할 메소드가 체크 예외를 던진다면 이를 catch 문으로 잡든지, 아니면 다시 throws를 정의해서 메소드 밖으로 던져야 한다. 그렇지 않으면 컴파일 에러가 발생한다.
- Java 언어와 JDK의 초기 설계자들은 체크 예외를 발생 가능한 예외에 모두 적용하려고 했던 것 같다. 그래서 IOException이나 SQLException을 비롯해서 예외적인 상황에서 던져질 가능성이 있는 것들 대부분이 체크 예외로 만들어져 있다.
<br/>

#### RuntimeException과 언체크/런타임 예외
- java.lang.RuntimeException 클래스를 상속한 예외들은 명시적인 예외처리를 강제하지 않기 때문에 언체크 예외라고 불린다. 또는 대표 클래스 이름을 따서 런타임 예외라고도 한다.
- 에러와 마찬가지로 런타임 예외는 catch 문으로 잡거나 throws로 선언하지 않아도 된다. (명시적으로 잡아도 상관은 없다)
- `런타임 예외는 주로 프로그램의 오류가 있을 때 발생하도록 의도된 것들`이다. 대표적으로 오브젝트를 할당하지 않은 레퍼런스 변수를 사용하려고 시도했을 때 발생하는 **NullPointerException**이나, 허용되지 않는 값을 사용해서 메소드를 호출할 때 발생하는 **IllegalArgumentException** 등이 있다. 이런 예외는 코드에서 미리 조건을 체크하도록 주의 깊게 만든다면 피할 수 있다.
- 피할 수 있지만 개발자가 부주의해서 발생할 수 있는 경우에 발생하도록 만든 것이 런타임 예외다. 따라서 런타임 예외는 예상하지 못했던 예외상황에서 발생하는 게 아니기 대문에 굳이 catch나 throws를 사용하지 않아도 되도록 만든 것이다.
<br/>

- 그런데 Java 언어를 설계하고 JDK를 개발한 사람들의 이런 설계의도는 현실과 잘 맞지 않았고 비난의 대상이 되기도 했다. 특히 체크 예외를 불필요성을 주장하는 사람들이 늘어났다.
- 체크 예외가 예외처리를 강제하는 것 때문에 예외 블랙홀이나 무책임한 throws 같은 코드가 남발됐다.
- 최근에 새로 등장하는 Java 표준 스펙의 API들은 예상 가능한 예외상황을 다루는 예외를 체크 예외로 만들지 않는 경향이 있기도 하다.
<br/>
