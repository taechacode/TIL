# 6장 AOP

## 6.1 트랜잭션 코드의 분리
### 6.1.1 메소드 분리
![비즈니스 로직과 트랜잭션 경계설정의 분리](https://github.com/taechacode/TIL/assets/63395751/c38c31ed-d2ea-4315-80bf-44b181f207c5)
**리스트 6-2 비즈니스 로직과 트랜잭션 경계설정의 분리**
- 트랜잭션 경계설정에 둘러싸여져 있는 비즈니스 로직을 외부로 빼내는 작업을 보여주고 있다.
- 기존 비즈니스 로직을 `upgradeLevelsInternal()`이라는 메소드로 만들고, 메소드에서 로직을 구현하고 있다.
<br/><br/>

### 6.1.2 DI를 이용한 클래스 분리
![UserService 인터페이스 도입을 통해 약한 결합을 갖는 유연한 구조](https://github.com/taechacode/TIL/assets/63395751/d5586217-43ae-4b04-93b1-3966256d61bb)
**그림 6-2 UserService 인터페이스 도입을 통해 약한 결합을 갖는 유연한 구조**
- 기존에는 UserService 클래스와 클라이언트의 직접 연결을 통한 강한 결합
- 인터페이스를 이용해 클라이언트와 UserService 구현 클래스의 직접 결합을 막아주고, 유연한 확장이 가능하게 만들었다.
<br/><br/>

![트랜잭션 경계설정을 위한 UserServiceTx의 도입](https://github.com/taechacode/TIL/assets/63395751/9f746db3-fa6c-4dbe-9612-f4b73284304c)
**그림 6-3 트랜잭션 경계설정을 위한 UserServiceTx의 도입**
- 한 번에 두 개의 UserService 인터페이스 구현 클래스를 동시에 이용한다면 어떨까? 클라이언트가 UserService의 기능을 제대로 이용하려면 트랜잭션이 적용돼야 한다.
- 위 그림과 같은 구조에서는 UserServiceTx가 사용자 관리 로직을 담고 있는 구현 클래스인 UserServiceImpl을 대신하기 위해 만든 게 아니다.
- UserServiceTx에서는 UserService를 구현한 다른 오브젝트를 DI 받고, 비즈니스 로직에 대해서는 아무런 관여도 하지 않는다.
- UserServiceTx에 트랜잭션의 경계설정이라는 부가적인 작업을 부여한다. 이 작업은 UserService에 트랜잭션 경계설정 API를 도입한 것과 동일하다.
<br/><br/>

![트랜잭션 기능의 오브젝트가 적용된 의존관계](https://github.com/taechacode/TIL/assets/63395751/e88fa643-278c-4a20-86ac-a90becbdc3f2)
**그림 6-4 트랜잭션 기능의 오브젝트가 적용된 의존관계**
<br/><br/>

#### 트랜잭션 경계설정 코드 분리의 장점
- 첫째, 비즈니스 로직을 담당하고 있는 UserServiceImpl의 코드를 작성할 때는 트랜잭션과 같은 기술적인 내용에는 전혀 신경쓰지 않아도 된다.
- 둘째, 비즈니스 로직에 대한 테스트를 손쉽게 만들어낼 수 있다.
<br/><br/>

## 6.2 고립된 단위 테스트
- 가장 편하고 좋은 테스트 방법은 가능한 한 작은 단위로 쪼개서 테스트하는 것이다.
- 작은 단위의 테스트가 좋은 이유는 테스트가 실패했을 때 그 원인을 찾기 쉽기 때문이다. 반대로 테스트에서 오류가 발견됐을 때 그 테스트가 진행되는 동안 실행된 코드의 양이 많다면 그 원인을 찾기가 매우 힘들어질 수 있다. 또한 테스트 단위가 작아야 테스트의 의도나 내용이 분명해지고, 만들기도 쉬워진다.
<br/><br/>

### 6.2.1 복잡한 의존관계 속의 테스트
- 책 그림 6-5를 보면 UserService를 분리하기 전의 테스트가 동작하는 모습을 보여주고 있다.
- UserService는 사용자 정보를 관리하는 비즈니스 로직의 구현 코드다. UserService의 코드가 바르게 작성되어 있으면 성공하고, 아니라면 실패하면 된다. 따라서 테스트의 단위는 UserService 클래스여야 한다.
- 하지만 UserService는 UserDao, TransactionManager, MailSender라는 3가지 의존관계를 갖고 있다. 따라서 그 3가지 `의존관계를 갖는 오브젝트들이 테스트가 진행되는 동안에 같이 실행된다`.
- 이런 경우의 테스트는 준비하기 힘들고, 환경이 조금이라도 달라지면 동일한 테스트 결과를 내지 못할 수도 있으며, 수행 속도는 느리고 그에 따라 테스트를 작성하고 실행하는 빈도가 점차로 떨어질 것이 분명하다. 그 오류 때문에 UserService의 테스트가 실패한다면 그 원인을 찾느라고 불필요한 시간을 낭비해야 할 수도 있다.
<br/><br/>

### 6.2.2 테스트 대상 오브젝트 고립시키기
#### 테스트를 위한 UserServiceImpl 고립
![고립시킨 UserServiceImpl에 대한 테스트 구조](https://github.com/taechacode/TIL/assets/63395751/acdad14c-4712-42d4-a965-fd7aaf21ddb8)
**그림 6-6 고립시킨 UserServiceImpl에 대한 테스트 구조**
- UserServiceImpl에 대한 테스트가 진행될 때 사전에 테스트를 위해 준비된 동작만 하도록 만든 2개의 목 오브젝트에만 의존하는, 완벽하게 고립된 테스트 대상으로 만들었다.
- UserDao는 단지 테스트 대상의 코드가 정상적으로 수행되도록 도와주기만 하는 스텁(Stub)이 아니라, 부가적인 검증 기능까지 가진 목 오브젝트로 만들었다. 그 이유는 고립된 환경에서 동작하는 upgradeLevels()의 테스트 결과를 검증할 방법이 필요하기 때문이다.
<br/><br/>

#### 고립된 단위 테스트 활용
- upgradeLevels() 테스트는 다음과 같은 단계로 진행된다.

1. 테스트 실행 중에 UserDao를 통해 가져올 테스트용 정보를 DB에 넣는다. UserDao는 결국 DB를 이용해 정보를 가져오기 때문에 최후의 의존 대상인 DB에 직접 정보를 넣어줘야 한다.
2. 메일 발송 여부를 확인하기 위해 MailSender에 목 오브젝트를 DI 해준다.
3. 실제 테스트 대상인 userService의 메소드를 실행한다.
4. 결과가 DB에 반영됐는지 확인하기 위해서 UserDao를 이용해 DB에서 데이터를 가져와 결과를 확인한다.
5. 목 오브젝트를 통해 UserService에 의한 메일 발송이 있었는지를 확인하면 된다.

- 처음 2가지는 UserService의 upgradeLevels() 메소드가 실행되는 동안에 사용하는 의존 오브젝트가 테스트의 목적에 맞게 동작하도록 준비하는 과정이다.
- 첫 번째 작업은 의존관계를 따라 마지막에 등장하는 DB를 준비하는 것인 반면에, 두 번째는 테스트를 의존 오브젝트와 서버 등에서 고립시키도록 테스트만을 위한 목 오브젝트를 준비한다는 점이 다르다.
- 네 번째와 다섯 번째는 테스트 대상 코드를 실행한 후에 결과를 확인하는 작업이다.
- 네 번째는 의존관계를 따라 결국 최종 결과가 반영된 DB의 내용을 확인하는 방법인 반면, 다섯 번째는 메일 서버까지 갈 필요 없이 목 오브젝트를 통해 upgradeLevels() 메소드가 실행되는 주엥 메일 발송 요청이 나간 적이 있는지만 확인하도록 되어 있다.
<br/><br/>

#### UserDao 목 오브젝트


## 6.3 다이내믹 프록시와 팩토리 빈
